<?xml version="1.0" encoding="UTF-8"?>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Pan Tutorial</title>

  <subtitle>Version<?eval ${project.version}?></subtitle>

  <info>
    <author>
      <personname><firstname>Charles</firstname><surname>Loomis</surname></personname>
    </author>

    <org>
      <orgname>Centre National de la Recherche Scientifique (CNRS)</orgname>
    </org>

    <abstract>
      <para>This tutorial introduces the pan compiler and pan configuration
      language. Those following the tutorial should understand the purpose of
      the pan compiler and how the pan configuration language allows a system
      administrator to describe the configuration of a machine. This tutorial
      highlights all of the major features of the pan language: simple
      declarative syntax, type checking, and extensive schema
      validation.</para>
    </abstract>

    <productnumber><?eval ${project.version}?></productnumber>

    <date><?eval ${buildTimestamp}?></date>

    <copyright>
      <year>2011</year>

      <holder>Centre National de la Recherche Scientifique (CNRS)</holder>
    </copyright>
  </info>

  <section>
    <title>Purpose of the Pan Compiler</title>

    <para>The pan compiler is a critical component of the quattor fabric
    management toolkit that translates a high-level site configuration written
    by a system administrator in the pan configuration language to a
    machine-readable representation. The pan configuration language allows a
    system administrator to define simultaneously both a site configuration
    and a schema for validation. One advantage the pan language has over, for
    example, XML and XMLSchema is that it is declarative language with a
    simple, human-friendly syntax. In addition, the typing features of the pan
    language allow more rigorous validation than XMLSchema.</para>

    <para>The name "compiler" is actually a misnomer, as the pan compiler does
    much more than a simple compilation. The processing progresses through
    five stages:</para>

    <variablelist>
      <varlistentry>
        <term>compilation</term>

        <listitem>
          <para>Compile each individual template (file written in the pan
          configuration language) into a binary format.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>execution</term>

        <listitem>
          <para>The statements in each object template are executed to
          generate a partial tree of configuration information. The object
          template usually includes many other templates during the course of
          execution. The generated tree contains all configuration information
          directly specified by the system administrator.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>insertion of defaults</term>

        <listitem>
          <para>A pass is made through the tree of configuration information
          during which default values (if specified) are inserted for missing
          elements. The tree of configuration information is complete after
          this stage.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>validation</term>

        <listitem>
          <para>The configuration information is frozen and all of the
          user-specified validation is run. (This is actually implemented as
          two separate validation passes to allow circular validation
          dependencies between machines.) Any invalid values or conditions
          will cause the processing to abort. If this stage finishes, then the
          configuration information is complete and validated.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>serialization</term>

        <listitem>
          <para>Once the information is complete and valid, it is serialized
          to a file. Usually, this file is in an XML format, but other
          representations are available as well.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>The pan compiler runs through these stages for each "object"
    template. An "object" template is a special template that indicates a
    configuration tree that should be serialized; usually there is one object
    template for each physical machine. (Although with the rise of
    virtualization, it may be one per logical machine.)</para>
  </section>

  <section>
    <title>Invoking the Pan Compiler</title>

    <para>In order to experiment with the pan compiler, you must first install
    it; see the pan compiler manual for instructions for downloading and
    installing an appropriate version. For this tutorial, the command line
    interface is the most convenient method for invoking the compiler.
    However, there are other mechanisms for invoking it directly from java or
    for integrating it with ant.</para>

    <para>Once you have installed the compiler, make sure that it is correctly
    installed by using the commands:</para>

    <screen>$ panc --version
$ panc --help</screen>

    <para>The first command will return the version of the compiler; the
    second will give a complete list of all of the available options.</para>

    <para>Now create a file named <filename>hello.tpl</filename> that contains
    the following:</para>

    <programlisting>object template hello;
'/message' = 'hello';</programlisting>

    <para>Now compile this profile into the default XML representation and
    look at the output.</para>

    <screen>$ panc hello.tpl
$ cat hello.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;nlist format="pan" name="profile"&gt;
&lt;string name="message"&gt;hello&lt;/string&gt;
&lt;/nlist&gt;</screen>

    <para>The output should look similar to what is shown above. As you can
    see the generated information has a simple structure: a top-level element
    of type <type>nlist</type>, named "profile" with a single
    <type>string</type> child, named "message". The value of the "message" is
    "hello". If the output format is not specified, the default is the "pan"
    XML style shown above, in which the element names are the pan primitive
    types and the name attribute gives the associated name of the element in
    the pan template.</para>

    <para>The pan compiler can generate output in three additional formats:
    xmldb, text, and dot. The xmldb format is a format in which the pan names
    are used for XML elements and the type attribute gives the element type.
    (If not specified, the default type is <type>string</type>.) The following
    shows the output for the xmldb format.</para>

    <screen>$ panc --xml-style=xmldb hello.tpl
$ cat hello.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;profile format="xmldb"&gt;
&lt;message type="string"&gt;hello&lt;/message&gt;
&lt;/profile&gt;</screen>

    <para>This format is convenient if the resulting output will be processed
    with tools like XSLT or XQuery because the XPath expression to use for a
    particular element is very close (but not identical) to the pan language
    path.</para>

    <para>For this tutorial, the most convenient representation will the the
    text format. This provides a clean representation of the configuration
    tree on a terminal.</para>

    <screen>$ panc --xml-style=text hello.tpl
$ cat hello.txt
+-profile
        $ message : (string) 'hello'</screen>

    <para>Note that the output file is named <filename>hello.txt</filename>
    and no longer <filename>hello.xml</filename>. It provides the same
    information as the XML formats, but is easier to understand
    visually.</para>

    <para>The last style is the "dot" format. This format produces an output
    file that <link xlink:href="http://www.graphviz.org/">Graphviz</link> can
    use to generate a graph of the configuration information.</para>

    <screen>$ panc --xml-style=dot hello.tpl
$ cat hello.dot
digraph "profile" {
bgcolor = beige
node [ color = black, shape = box, fontname=Helvetica ]
edge [ color = black ]
"/profile" [ label = "profile" ]
"/profile/message" [ label = "message\n'hello'" ]
"/profile" -&gt; "/profile/message"
}</screen>

    <para>Although the text is not very enlightening by itself, it can be used
    by Graphviz to generate a graph of the configuration. Processing the above
    file with Graphviz produces the image shown in <xref
    linkend="fig-hello" />. The images in the tutorial have been produced with
    the dot output of the compiler.</para>

    <figure xml:id="fig-hello">
      <title>Graph of configuration produced by
      <filename>hello.tpl</filename>.</title>

      <mediaobject>
        <alt>Graph of configuration produced by the file hello.tpl.</alt>

        <imageobject role="html">
          <imagedata fileref="images/hello.png" format="PNG"></imagedata>
        </imageobject>

        <imageobject role="fo">
          <imagedata fileref="images/hello.svg" format="SVG"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>
  </section>

  <section>
    <title>Tutorial Scenario</title>

    <para>This tutorial will demonstrate how to define a configuration schema
    and populate it with values using the pan configuration language. To keep
    this tutorial from becoming a dry exercise of pan functionality, a
    simplified but typical configuration scenario will be used. A system
    administrator has four machines that need to be installed. One of the
    machines will be an NFS server to provide a shared file system to the
    other three machines. One of the machines will be the head node of a batch
    system and the other two will be the batch system clients, or worker
    nodes.</para>

    <para>The corresponding configuration schema will consist of both hardware
    and software aspects of the configuration. For the hardware aspects, the
    schema will include information about the location of the machine, RAM,
    CPUs, disks, and network interface cards (NICs). The software
    configuration will include parameters for configuring an NFS server, NFS
    client, batch system head node, and batch system client. The software
    configuration will also contain information about some related low-level
    services such as a firewall.</para>

    <para>The schema developed in this tutorial borrows ideas from the
    standard Quattor schema. However for pedagogical reasons, the schema here
    is simplified to demonstrate the essential pan language features. At the
    end of the tutorial, readers should understand the core features of the
    pan configuration language and be able to understand the standard Quattor
    schema. Additional work with other components of the Quattor system will
    be necessary to use Quattor to configure a real set of machines.</para>
  </section>

  <section>
    <title>Setting Configuration Values</title>

    <para>The pan configuration language is a declarative language that allows
    configuration parameters arranged in a hierarchical tree to be given
    values. At its simplest level, pan simply sets key/value pairs where the
    keys can be arranged hierarchically. Consider initially the hardware
    information for the machines: location of the machine, RAM, CPUs, disks,
    and network interface cards (NICs). One possible way of specifying this
    information in pan is the following:</para>

    <programlisting>object template nfsserver.example.org;

'/hardware/location/rack' = 'IBM04';
'/hardware/location/slot' = 25;

'/hardware/ram' = 2048;

'/hardware/cpu/model' = 'Intel Xeon';
'/hardware/cpu/speed' = 2.5;
'/hardware/cpu/arch' = 'x86_64';
'/hardware/cpu/cores' = 4;
'/hardware/cpu/number' = 2;

'/hardware/disks/ide/0/capacity' = 64;
'/hardware/disks/ide/0/boot' = true;
'/hardware/disks/ide/0/label' = 'system';
'/hardware/disks/ide/1/capacity' = 1024;
'/hardware/disks/ide/1/boot' = false;

'/hardware/nic/0/mac' = '01:23:45:ab:cd:99';
'/hardware/nic/0/pxeboot' = false;
'/hardware/nic/1/mac' = '01:23:45:ab:cd:00';
'/hardware/nic/1/pxeboot' = true;</programlisting>

    <para>In this example, each assignment statement sets one value. On the
    left-hand side is the absolute path, which must be a single- or
    double-quoted string; the right-hand side is the value to assign to that
    path. All absolute paths must begin with a slash. Save this to the file
    <filename>nfsserver.example.org.tpl</filename>. Invoking the pan compiler
    on this will cause a configuration tree to be built by executing the
    assignment statements in order from the beginning to the end. The text
    representation of the compiler output looks like:</para>

    <screen>$ panc --xml-style=text nfsserver.example.org
$ cat nfsserver.example.org.txt
+-profile
        +-hardware
                +-cpu
                        $ arch : (string) 'x86_64'
                        $ cores : (long) '4'
                        $ model : (string) 'Intel Xeon'
                        $ number : (long) '2'
                        $ speed : (double) '2.5'
                +-disks
                        +-ide
                                +-0
                                        $ boot : (boolean) 'true'
                                        $ capacity : (long) '64'
                                        $ label : (string) 'system'
                                +-1
                                        $ boot : (boolean) 'false'
                                        $ capacity : (long) '1024'
                +-location
                        $ rack : (string) 'IBM04'
                        $ slot : (long) '25'
                +-nic
                        +-0
                                $ mac : (string) '01:23:45:ab:cd:99'
                                $ pxeboot : (boolean) 'false'
                        +-1
                                $ mac : (string) '01:23:45:ab:cd:00'
                                $ pxeboot : (boolean) 'true'
                $ ram : (long) '2048'</screen>

    <para>showing how a machine with an dual-CPU machine with Intel Xeon chips
    running at 2.5 GHz, 2 GB of RAM, two IDE disks, two NICs, and located in
    rack IBM04 in slot 25 could be represented. This information could then be
    used by other parts of the Quattor toolkit (or any other tool for that
    matter) to do some work based on this information, although the XML format
    is usually used when transmitting the information to other tools.</para>

    <para>Although this example should be fairly intuitive for most readers,
    there are a few subtleties to point out. The first line of the example
    indicates that this file represents a "managed object" and should produce
    an output file. If the <literal>object</literal> modifier is left out,
    then the file will compile but no output file will be produced. The
    tutorial will explain the different types of templates later.</para>

    <para>Notice that it was not necessary to specify all of the parents of a
    particular path. For example, there was no assignment statement with the
    path <literal>/hardware</literal>. When assigning a value to a particular
    path, pan will automatically create the parents as necessary. In the pan
    language, the leaves of the tree (terminal values) are called
    <emphasis>properties</emphasis>. All of the assignment statements in this
    example set properties. The branches of the tree (collections) are
    generically called <emphasis>resources</emphasis>. The term
    <emphasis>element</emphasis> encompasses both pan properties and
    resources.</para>

    <section>
      <title>Properties and Primitive Types</title>

      <para>The properties can have any of the primitive types that pan
      supports: <type>long</type>, <type>double</type>, <type>boolean</type>,
      and <type>string</type>. The syntax for writing literal values is the
      same as most modern programming languages. In addition to the usual
      base-10 format for long literals, octal and hexadecimal literals can
      also be specified by using a leading '0' or '0x' respectively. For
      example, fifteen can be written as <literal>15</literal>,
      <literal>017</literal>, or <literal>0xf</literal>. Double literals can
      be specified with or without an exponent. One particularity of pan is
      that all double literals must start with a digit. That is,
      <literal>.2</literal> is not a valid double literal and must instead be
      written as <literal>0.2</literal>.</para>

      <para>String values may be specified with a single-quoted,
      double-quoted, or a <emphasis>heredoc</emphasis> syntax. All characters
      within a single-quoted string are taken literally. For example, the
      string <literal>'no new line\n'</literal> will contain a backslash and
      character <literal>n</literal> at the end of the string. The only
      exception is that a doubled single quote represents a single literal
      quote within a single-quoted value. It is best practice to use
      single-quoted strings to specify path values. In contrast, the
      double-quoted string <literal>"with a new line\n"</literal> will contain
      a new line character at the end. All of the usual c-style escape
      sequences are supported. For long multi-line strings, the
      <emphasis>heredoc</emphasis> syntax may be used:</para>

      <programlisting>object template heredoc;

'/longstring' = &lt;&lt;EOF;
This is a 
long multiline
string.
EOF</programlisting>

      <para>The token after the <literal>&lt;&lt;</literal> operator will mark
      the end of the multi-line string and can be chosen by the user. The
      string will begin after the next new line in the source template and end
      before the line containing the end token. The ending token must appear
      on a separate line by itself; no other characters (including whitespace)
      may appear on the line with the ending token.</para>
    </section>

    <section>
      <title>Resources</title>

      <para>There are two types of <emphasis>resources</emphasis> supported by
      pan: list and nlist. A list is an ordered list of elements with the
      indexing starting at zero. In the above example, there are two lists
      <literal>/hardware/disks/ide</literal> and
      <literal>/hardware/nic</literal>. The order of a list is significant and
      maintained in the serialized representation of the configuration. An
      nlist (named list) associates a name with an element; these are also
      known as hashes or associative arrays. One nlist in the above example is
      <literal>/hardware/cpu</literal>, which has <literal>arch</literal>,
      <literal>cores</literal>, <literal>model</literal>,
      <literal>number</literal>, and <literal>speed</literal> as children.
      Note that the order of an nlist is <emphasis>not</emphasis> significant
      and that the order specified in the template file is
      <emphasis>not</emphasis> preserved in the serialized version of the
      configuration. Although the algorithm for ordering the children of an
      nlist in the serialized file is not specified, the pan compiler
      guarantees a <emphasis>consistent</emphasis> ordering of the same
      children from one compilation to the next.</para>

      <para>Within a given path, lists and nlists can be distinguished by the
      names of their children. Lists always have children whose names are
      valid long literals. In the following example, /mylist is a list with
      three children:</para>

      <programlisting>object template mylist;

'/mylist/0' = 'decimal index';
'/mylist/01' = 'octal index';
'/mylist/0x3' = 'hexadecimal index';</programlisting>

      <para>The indices can be specified in decimal, octal, or hexadecimal.
      The names of children in an nlist must begin with a letter or
      underscore.</para>
    </section>

    <section>
      <title>Exercises</title>

      <orderedlist>
        <listitem>
          <para>Pan creates parent resources automatically inferring the type
          of resource (list or nlist) from the path itself. What happens if
          two assignment statements implicitly define different types for a
          resource?</para>
        </listitem>

        <listitem>
          <para>What happens if a list is defined with a "hole" in it? Try
          defining and compiling a template in which a list only has the third
          element (index = 2) defined.</para>
        </listitem>

        <listitem>
          <para>What happens if you redefine the same path later in the same
          template? Which value appears in the serialized file?</para>
        </listitem>

        <listitem>
          <para>What happens if you redefine the same path later in the same
          template but assign a value with a different primitive type? What
          happens if you define the path to the special literal
          <literal>undef</literal> between those two assignments?</para>
        </listitem>

        <listitem>
          <para>What happens if you define the
          <literal>/hardware/cpu/number</literal> to be a boolean or string
          value?</para>
        </listitem>

        <listitem>
          <para>Can you delete a property or resource that was previously
          defined in the template? Hint: try using the special literal
          <literal>null</literal>.</para>
        </listitem>

        <listitem>
          <para>What happens if you try to set a path that does not begin with
          a slash?</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section>
    <title>Simple Type Checking</title>

    <para>If you worked through the exercises of the previous section, you
    will have discovered that although you have an intuitive idea of what type
    a particular path should contain (e.g.
    <literal>/hardware/cpu/number</literal> should be positive long), the pan
    compiler does not. Downstream tools to configure a machine will likely
    expect certain values to have certain types and will produce errors or
    erroneous configurations if the correct type is not used. One of the
    strengths of the pan language is to specify constraints on the values to
    detect problems before configurations are deployed to machines.</para>

    <section>
      <title>Binding Primitive Types to Paths</title>

      <para>At the most basic level, a system administrator can tell the pan
      compiler that a particular element must be a particular type. This is
      done with the <literal>bind</literal> statement. To tell the compiler
      that the path <literal>/hardware/cpu/number</literal> must be a long
      value, add the following statement to the
      <literal>nfsserver.example.org</literal> example.</para>

      <programlisting>bind '/hardware/cpu/number' = long;</programlisting>

      <para>This statement can appear anywhere in the file; all of the
      specified constraints will be verified <emphasis>after</emphasis> the
      complete configuration is built. Setting this path to a value that is
      not a long or not setting the value at all will cause the compilation to
      fail.</para>

      <para>The above constraint only does part of the work though; the value
      could still be set to zero or a negative value without having the
      compiler complain. Pan also allows a range to be specified for primitive
      values. Changing the statement to the following:</para>

      <programlisting>bind '/hardware/cpu/number' = long(1..);</programlisting>

      <para>will require that the value be a positive long value. A valid
      range can have the minimum value, maximum value, or both specified. A
      range is always <emphasis>inclusive</emphasis> of the endpoint values.
      The endpoint values must be long literal values. A range specified as a
      single value indicates an exact match (e.g. <literal>3</literal> is
      short-hand for <literal>3..3</literal>). A range can be applied to a
      <type>long</type>, <type>double</type>, or <type>string</type> value.
      For strings, the range is applied to the length of the string. A range
      cannot be applied to <type>boolean</type> values.</para>
    </section>

    <section>
      <title>User-Defined Types</title>

      <para>While one could imagine adding bind statements for every named
      element within a configuration tree, this would quickly become tedious.
      To avoid unnecessary duplication, pan allows user-defined types both for
      properties and resources. One could define, for example, a type for a
      port number and then privileged and unprivileged ports:</para>

      <programlisting>type port = long(0..65535);
type priv_port = port(..1024);
type unpriv_port = port(1025..);</programlisting>

      <para>The above statements would define three new types:
      <type>port</type>, <type>priv_port</type>, and <type>unpriv_port</type>.
      Note that once a type has been defined, it may be used anywhere in the
      pan language that native types are allowed. Here the privileged and
      unprivileged port types are defined in term of <type>port</type>. The
      order is significant here; a valid type definition can only reference
      types that have been previously defined. Defining "alias" types like
      this can reduce errors by enforcing consistent constraints and improve
      the readability of the code if appropriate names are chosen.</para>

      <para>User-defined types can be bound to a path using exactly the same
      syntax as for binding with primitive types. Once again order is
      significant; referenced types must be defined before a
      <literal>bind</literal> statement is executed.</para>

      <para>Homogeneous resources can be easily defined by adding brackets or
      braces to a type definition:</para>

      <programlisting>type port_list = port[];
type port_nlist = port{};</programlisting>

      <para>where these define a list or nlist, respectively. Empty brackets
      or braces means that there are no restrictions on the size of the
      resource; the resources may also be empty. If the brackets or braces
      contain a range, the constraint is applied to the size of the resource.
      For example, <literal>long[3]</literal> would be a long list with
      exactly three children and <literal>long[1..]</literal> would be a long
      list with one or more children.</para>

      <para>One of the most common user-defined types is that of a
      <emphasis>record</emphasis>. A record is an nlist with specific, named
      children defined. For example, one can specify a <type>disk_info</type>
      type to define the disk information in the
      <literal>nfsserver.example.org</literal> example:</para>

      <programlisting>type disk = {
  'label' ? string
  'capacity' : long(1..)
  'boot' : boolean
};</programlisting>

      <para>This type definition would be an <type>nlist</type> with three
      children named <literal>label</literal>, <literal>capacity</literal>,
      and <literal>boot</literal>. The <literal>label</literal> is an optional
      child (indicated by the question mark) and may or may not exist.
      However, if it does exist then the given type constraint must be met.
      The other two are required children and they must exist for the type
      definition to validate correctly. Children with other names are not
      permitted by this type definition.</para>

      <para>Occasionally it is useful to define an open or extensible record
      that allows children not specified in the type definition to exist.
      Imagine that for the machine location that the <literal>rack</literal>
      and <literal>slot</literal> information is required, but other
      information could be added as well. The following record
      definition:</para>

      <programlisting>type location = extensible {
  'rack' : string
  'slot' : long(0..50)
};</programlisting>

      <para>would allow someone to add information like the building number
      without violating this type's constraints.</para>
    </section>

    <section>
      <title>Schema Definition</title>

      <para>Using type definitions for properties and resources, one can build
      a global schema for a configuration. Using a global schema is extremely
      important when using pan to define configurations because it allows
      extensive compile-time checking of the configuration, avoiding having to
      cleanup the mess that can result from deploying a bad configuration. The
      following revisits the <literal>nfsserver.example.org</literal>
      configuration by adding a full schema:</para>

      <programlisting>object template nfsserver.example.org;

type location = extensible {
  'rack' : string
  'slot' : long(0..50)
};

type cpu = {
  'model' : string
  'speed' : double(0..)
  'arch' : string
  'cores' : long(1..)
  'number' : long(1..)
};

type disk = {
  'label' ? string
  'capacity' : long(1..)
  'boot' : boolean
};

type disks = {
  'ide' ? disk[]
  'scsi' ? disk{}
};

type nic = {
  'mac' : string
  'pxeboot' : boolean
};

type hardware = {
  'location' : location
  'ram' : long(0..)
  'cpu' : cpu
  'disks' : disks
  'nic' : nic[]
};

type root = {
  'hardware' : hardware
};

bind '/' = root;

'/hardware/location/rack' = 'IBM04';
'/hardware/location/slot' = 25;

'/hardware/ram' = 2048;

'/hardware/cpu/model' = 'Intel Xeon';
'/hardware/cpu/speed' = 2.5;
'/hardware/cpu/arch' = 'x86_64';
'/hardware/cpu/cores' = 4;
'/hardware/cpu/number' = 2;

'/hardware/disk/ide/0/capacity' = 64;
'/hardware/disk/ide/0/boot' = true;
'/hardware/disk/ide/0/label' = 'system';
'/hardware/disk/ide/1/capacity' = 1024;
'/hardware/disk/ide/1/boot' = false;

'/hardware/nic/0/mac' = '01:23:45:ab:cd:99';
'/hardware/nic/0/pxeboot' = false;
'/hardware/nic/1/mac' = '01:23:45:ab:cd:00';
'/hardware/nic/1/pxeboot' = true;</programlisting>

      <para>The series of type definitions progressively define the full
      schema from the lowest to highest levels. Note that there is only one
      <literal>bind</literal> statement in this configuration. This
      <literal>bind</literal> statement binds the root resource, specified by
      the path <literal>'/'</literal>, to the root of the schema. All of the
      other definitions are bound implicitly through this one
      statement.</para>
    </section>

    <section>
      <title>Exercises</title>

      <orderedlist>
        <listitem>
          <para>Determine what happens if the type definitions are specified
          in the wrong order.</para>
        </listitem>

        <listitem>
          <para>Verify that the type definitions are fully applied to the
          <literal>nfsserver.example.org</literal> example by specifying some
          invalid values.</para>
        </listitem>

        <listitem>
          <para>Also verify that adding paths outside of the schema is caught
          by the validation.</para>
        </listitem>

        <listitem>
          <para>Although the schema in the last
          <literal>nfsserver.example.org</literal> template is much more
          restrictive, there are still several places where simple typos or
          inconsistent values could produce an invalid configuration. Where
          are they? What would you want to do to fix them?</para>
        </listitem>

        <listitem>
          <para>What happens if you bind several different types to the same
          path?</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section>
    <title>Modular Configuration</title>

    <section>
      <title>Include Statement</title>

      <para>So far only the hardware configuration and schema for one machine
      has been defined with the <literal>nfsserver.example.org</literal>
      configuration. One could imagine just doing a cut and paste to create
      the other three machines in our scenario. While this will work, the
      global site configuration will quickly become unwieldy and error-prone.
      In particular the schema is something that should be shared between all
      or many machines on a site. Multiple copies means multiple copies to
      keep up-to-date and multiple chances to introduce errors.</para>

      <para>To encourage reuse of the configuration and to reduce maintenance
      effort, pan allows one template to include another (with some
      limitations). For example, the above schema can be pulled into another
      template (named <filename>common/schema.tpl</filename>) and included in
      the main object template.</para>

      <programlisting>declaration template common/schema;

type location = extensible {
  'rack' : string
  'slot' : long(0..50)
};

type cpu = {
  'model' : string
  'speed' : double(0..)
  'arch' : string
  'cores' : long(1..)
  'number' : long(1..)
};

type disk = {
  'label' ? string
  'capacity' : long(1..)
  'boot' : boolean
};

type disks = {
  'ide' ? disk[]
  'scsi' ? disk{}
};

type nic = {
  'mac' : string
  'pxeboot' : boolean
};

type hardware = {
  'location' : location
  'ram' : long(0..)
  'cpu' : cpu
  'disks' : disks
  'nic' : nic[]
};

type root = {
  'hardware' : hardware
};</programlisting>

      <para>The main object template then becomes:</para>

      <programlisting>object template nfsserver.example.org;

include { 'common/schema' };

bind '/' = root;

'/hardware/location/rack' = 'IBM04';
'/hardware/location/slot' = 25;

'/hardware/ram' = 2048;

'/hardware/cpu/model' = 'Intel Xeon';
'/hardware/cpu/speed' = 2.5;
'/hardware/cpu/arch' = 'x86_64';
'/hardware/cpu/cores' = 4;
'/hardware/cpu/number' = 2;

'/hardware/disk/ide/0/capacity' = 64;
'/hardware/disk/ide/0/boot' = true;
'/hardware/disk/ide/0/label' = 'system';
'/hardware/disk/ide/1/capacity' = 1024;
'/hardware/disk/ide/1/boot' = false;

'/hardware/nic/0/mac' = '01:23:45:ab:cd:99';
'/hardware/nic/0/pxeboot' = false;
'/hardware/nic/1/mac' = '01:23:45:ab:cd:00';
'/hardware/nic/1/pxeboot' = true;</programlisting>

      <para>There are three important changes to point out.</para>

      <para>First, there is a new pan statement in the
      <literal>nfsserver.example.org</literal> template to include the schema.
      The <literal>include</literal> statement takes the name of the template
      to include as a string; the braces are mandatory. If the template is not
      included directly on the command line, then the compiler will search the
      <emphasis>loadpath</emphasis> for the template. If the loadpath is not
      specified, then it defaults to the current working directory.</para>

      <para>Second, the schema has been pulled out into a separate file. The
      first line of that schema template is now marked as a
      <literal>declaration</literal> template. Such a template can only
      include type declarations. (Also variable and function declarations as
      we will see later.) Such a template will be included at most once when
      building an object; all inclusions after the first will be ignored. This
      allows many different template to reference type (and function)
      declarations that they use without having to worry about accidentally
      redefining them.</para>

      <para>Third, the schema template name is
      <literal>common/schema</literal> and must be located in a file called
      <filename>common/schema.tpl</filename>; that is, it must be in a
      subdirectory of the current directory called
      <filename>common</filename>. This is called
      <emphasis>namespacing</emphasis> and allows the templates that make up a
      configuration to be organized into subdirectories. For the few templates
      that are used in this tutorial, namespacing is not critical. It is,
      however, critical for real sites that are likely to have hundreds or
      thousands of templates. Note that the hierarchy for namespaces is
      completely independent of the hierarchy used in the configuration
      schema.</para>

      <para>Pulling out common declarations and help maintain coherence
      between different managed machines and reduce the overall size of the
      configuration. There are however, more mechanisms to reduce
      duplication.</para>
    </section>

    <section>
      <title>Structure Templates</title>

      <para>Sites usually buy many identical machines in a single purchase, so
      much of the hardware configuration for those machines is the same.
      Another mechanism that can be exploited to reuse configuration
      parameters is a <literal>structure</literal> template. Such a template
      defines an nlist that is initially independent of the configuration tree
      itself. For our scenario, let us assume that the four machines have
      identical RAM, CPU, and disk configurations; the NIC and location
      information is different for each machine. The following template pulls
      out the common information into a <literal>structure</literal>
      template:</para>

      <programlisting>structure template common/machine/ibm-server-model-123;

'ram' = 2048;

'cpu/model' = 'Intel Xeon';
'cpu/speed' = 2.5;
'cpu/arch' = 'x86_64';
'cpu/cores' = 4;
'cpu/number' = 2;

'disk/ide/0/capacity' = 64;
'disk/ide/0/boot' = true;
'disk/ide/0/label' = 'system';
'disk/ide/1/capacity' = 1024;
'disk/ide/1/boot' = false;

'location' = undef;
'nic' = undef;</programlisting>

      <para>The structure template is not rooted into the configuration (yet)
      and hence all of the paths in the assignment statements must be
      <emphasis>relative</emphasis>; that is, they do not begin with a slash.
      Also, the <literal>location</literal> and <literal>nic</literal>
      children were set to <literal>undef</literal>. These are the values that
      will vary from machine to machine, but we want to ensure that anyone
      using this template sets those values. If someone uses this template,
      but forgets to set those values, the compiler will abort the compilation
      with an error. The <literal>undef</literal> value may not appear in a
      final configuration.</para>

      <para>How is this used in the machine configuration? The
      <literal>include</literal> statement will not work because we must
      indicate where the configuration should be rooted. The answer is to use
      an assignment statement along with the <function>create</function>
      function.</para>

      <programlisting>object template nfsserver.example.org;

include { 'common/schema' };

bind '/' = root;

'/hardware' = create('common/machine/ibm-server-model-123');

'/hardware/location/rack' = 'IBM04';
'/hardware/location/slot' = 25;

'/hardware/nic/0/mac' = '01:23:45:ab:cd:99';
'/hardware/nic/0/pxeboot' = false;
'/hardware/nic/1/mac' = '01:23:45:ab:cd:00';
'/hardware/nic/1/pxeboot' = true;</programlisting>

      <para>Finally, the machine configuration contains only values that
      depend on the machine itself with common values pulled in from shared
      templates.</para>

      <para>Although the example here uses the hardware configuration, in
      reality it can be used for any subtree that is invariant or
      nearly-invariant. One can even reuse the same structure template many
      times in the same object just be creating a new instance and assigning
      it to a particular part of the tree.</para>
    </section>

    <section>
      <title>Exercises</title>

      <orderedlist>
        <listitem>
          <para>What happens if you put an absolute assignment statement in a
          structure template?</para>
        </listitem>

        <listitem>
          <para>What happens if you put a relative assignment statement in an
          object template?</para>
        </listitem>

        <listitem>
          <para>Come up with an example where you might want to reuse the same
          structure template several times in the same object.</para>
        </listitem>

        <listitem>
          <para>What happens if you try to include an object template from
          another object, declaration, or structure template?</para>
        </listitem>

        <listitem>
          <para>What happens if you try to include a structure template with
          an include statement?</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section>
    <title>Default Values</title>

    <para>Looking again at the nfsserver.example.org configuration, there are
    a couple of places where we could hope to use default values. The
    <literal>pxeboot</literal> and <literal>boot</literal> flags in the
    <type>nic</type> and <type>disk</type> type definitions could use default
    values. In both cases, at most one value will be set to
    <literal>true</literal>; all other values will be set to
    <literal>false</literal>. Another place one might want to use default
    values is in the <type>cpu</type> type; perhaps we would like to have
    <literal>number</literal> and <literal>cores</literal> both default to 1
    if not specified.</para>

    <para>Pan allows type definitions to contain default values. For example,
    to change the three type definitions mentioned above:</para>

    <programlisting>type cpu = {
  'model' : string
  'speed' : double(0..)
  'arch' : string
  'cores' : long(1..) = 1
  'number' : long(1..) = 1
};

type nic = {
  'mac' : string
  'pxeboot' : boolean = false
};

type disk = {
  'label' ? string
  'capacity' : long(1..)
  'boot' : boolean = false
};</programlisting>

    <para>With these definitions, the lines which set the
    <literal>pxeboot</literal> and <literal>boot</literal> flags to false can
    be removed from the configuration and the compiler will still produce the
    same result. The default value will only be used if the corresponding
    element does not exist or has the <literal>undef</literal> value
    <emphasis>after all</emphasis> of the statements for an object have been
    executed. Consequently, a value that has been explicitly defined will
    always be used in preference to the default. Although one can set a
    default value for an optional field in a record, it will have an effect
    <emphasis>only</emphasis> if the value was explicitly set to
    <literal>undef</literal>.</para>

    <para>The default values must be a compile time constants.</para>

    <section>
      <title>Exercises</title>

      <orderedlist>
        <listitem>
          <para>Update the schema template using the type definitions with
          defaults. Remove the unnecessary lines in the
          <literal>nfsserver.example.org</literal> template and ensure that
          the defaults are correctly used.</para>
        </listitem>

        <listitem>
          <para>Can you set a default value to an illegal value? When is the
          illegal value detected?</para>
        </listitem>

        <listitem>
          <para>Can you set a default value to
          <literal>undef</literal>?</para>
        </listitem>

        <listitem>
          <para>Set a default value for an optional field and see if/when this
          is used?</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section>
    <title>Data Manipulation Language</title>

    <para>Although a declarative language has many benefits, there are times
    when values need to be calculated or verified based on some algorithm. To
    allow this in the pan language without giving up the fundamental
    declarative nature of the language, pan allows a Data Manipulation
    Language (DML) block to appear in most places where a literal value can
    appear. The DML block can use information contained in global variables,
    in the current object, or in other objects to calculate a value. This
    makes the language much more flexible without giving up the simplicity of
    the overall pan syntax.</para>

    <para>A DML block is a sequence of one or more expressions, where every
    expression returns a value. The value for an entire DML block is the value
    of the last executed statement. The DML syntax looks like a simplified
    version of c. The DML block can only return a value and cannot directly or
    indirectly change the configuration tree nor the global state except by
    assigning the return value to a path or variable.</para>

    <section>
      <title>Operators</title>

      <para>DML has a complete set of operators for arithmetic, bit
      operations, and comparison operators. These are identical to those
      available in Java, including that the plus operator (+) works also to
      concatenate strings. See the pan language reference for a complete list
      of all of the operators. Where necessary in a calculation, DML will
      promote long values to doubles; no other automatic conversions are
      performed.</para>

      <programlisting>'/result1' = 147 + 10;  # will be 157
'/result2' = 153 == (150 + 3);  # will be true
'/result3' = {
  5 + 5;
  20 % 5;
  6 * 5.0;
};  # will be 30.0</programlisting>

      <para>In assignment statements, single expressions can be used after the
      equal sign without brackets. DML blocks with multiple statements must be
      surrounded by braces. DML blocks may appear as default values in type
      definitions if the block evaluates to a constant, compile-time
      value.</para>
    </section>

    <section>
      <title>Variables</title>

      <para>There are three types of variables in the pan language. Local
      variables defined and used within a DML block, global variables defined
      by the <literal>variable</literal> statement and automatic variables
      provided by the compiler.</para>

      <para>Local variables can be defined within a DML block simply by
      assigning a value to them. There is no need to declare the variable
      before assigning a value; the variable must have been defined before
      using it on the right-side of an expression.</para>

      <programlisting>'/result' = {
  x = 10;
  y = 20;
  z = 30;
  x + y - z;
};  # will be zero</programlisting>

      <para>Once the DML block has finished, all of the local variables are
      destroyed and are no longer accessible.</para>

      <para>Global variables can be defined by using the pan
      <literal>variable</literal> statement. For example,</para>

      <programlisting>variable X = 'hello world!';</programlisting>

      <para>will define a global variable <varname>X</varname> that will be
      accessible from any DML block evaluated after this
      <literal>variable</literal> statement is executed. The variable
      definition is available until the end of the validation phase. Note that
      global variables are global with respect the the object being compiled.
      Each object has its own variable table; thus global variables cannot be
      used to transmit information between objects. To avoid naming conflicts
      between global and local variables, it is best practice to use all
      capital letters for global variable names.</para>

      <para>Automatic variables are provided by the compiler in certain
      contexts. The automatic variables are <varname>SELF</varname>,
      <varname>OBJECT</varname>, <varname>FUNCTION</varname>,
      <varname>ARGC</varname>, and <varname>ARGV</varname>. The variable
      <varname>OBJECT</varname> is the easiest to explain; it contains the
      name of the object currently being executed.</para>

      <programlisting>object template dummy.example.org;
'/name' = OBJECT;</programlisting>

      <para>The path will contain the string "dummy.example.org" after
      execution. As the object templates are usually named either directly or
      indirectly after the machines hostname, <varname>OBJECT</varname> is
      often used to lookup host-specific information. The
      <varname>FUNCTION</varname> variable contains the name of the current
      function, often used for debugging or error statements. The
      <varname>ARGC</varname> and <varname>ARGV</varname> variables are
      defined only within a user-defined function and correspond to the number
      of arguments and a list of those arguments, respectively.</para>

      <para>In an assignment statement, <varname>SELF</varname> contains the
      value of the path before the DML block started executing. Within a DML
      block, one cannot directly change the value of <varname>SELF</varname>
      but one can indirectly change the value by assigning values to children
      of <varname>SELF</varname>. This is best illustrated by an
      example:</para>

      <programlisting>object template self-test;

'/result/a' = 'value a is set';

'/result' = {
  SELF['b'] = 'value b is set';
  SELF;
};</programlisting>

      <screen>$ panc --xml-style=text self-test.tpl
$ cat self-test.txt 
+-profile
        +-result
                $ a : (string) 'value a is set'
                $ b : (string) 'value b is set'</screen>

      <para>The compiler optimizes references to the <varname>SELF</varname>
      variable, so making incremental changes to a resource like this is
      recommended. One common error when using <varname>SELF</varname> is not
      to remember to return <varname>SELF</varname> as the last expression in
      a block; this can lead to unexpected results or errors.</para>

      <para>Any type can define a DML block to act as a validation function
      during the validation phase. The DML block in this case must return
      <literal>true</literal>, if the validation was OK, or
      <literal>false</literal>, otherwise. In such a validation block, the
      <varname>SELF</varname> variable is assigned the value of the element
      being validated. No changes whatsoever can be made to the configuration
      tree or to the <varname>SELF</varname> variable during the validation
      phase.</para>
    </section>

    <section>
      <title>Functions</title>

      <para>There are a large number of built-in functions available; see the
      pan language reference for the complete list. The most commonly used
      functions are given in the following table.</para>

      <informaltable>
        <tgroup cols="2">
          <colspec align="center" />

          <tbody>
            <row>
              <entry><function>nlist</function>(key, value, ...)</entry>

              <entry>create an nlist from the given parameters</entry>
            </row>

            <row>
              <entry><function>list</function>(value, ...)</entry>

              <entry>create a list from the given parameters</entry>
            </row>

            <row>
              <entry><function>create</function>(name, key, value,
              ...)</entry>

              <entry>create an nlist from the named structure template and
              provided key/value pairs</entry>
            </row>

            <row>
              <entry><function>length</function>(resource),
              <function>length</function>(string)</entry>

              <entry>returns the length of the given resource or
              string</entry>
            </row>

            <row>
              <entry><function>match</function>(regexp, string)</entry>

              <entry>return boolean indicating if the given string matches the
              given regular expression</entry>
            </row>

            <row>
              <entry><function>matches</function>(regexp, string)</entry>

              <entry>return a list of matched groups based on the given
              regular expression and string</entry>
            </row>

            <row>
              <entry><function>to_string</function>(value),
              <function>to_long</function>(value),
              <function>to_boolean</function>(value),
              <function>to_double</function>(value)</entry>

              <entry>type conversion functions</entry>
            </row>

            <row>
              <entry><function>is_string</function>(value),
              <function>is_list</function>(value),
              <function>is_nlist</function>(value), ...</entry>

              <entry>type checking functions return a boolean if the argument
              is of the indicated type</entry>
            </row>

            <row>
              <entry><function>debug</function>(message),
              <function>traceback</function>(message),
              <function>error</function>(message)</entry>

              <entry>debugging functions; <function>debug</function> and
              <function>traceback</function> will return
              <literal>undef</literal>; <function>error</function> will abort
              the processing</entry>
            </row>

            <row>
              <entry>value(path)</entry>

              <entry>return the value at the named path; the path may be an
              absolute or external path</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>In addition to the built-in functions, users can also define
      functions. The <literal>function</literal> statement allows any DML
      block to be treated as a function. After the function is defined, it may
      be called within any subsequent block just as a built-in function could.
      For example, the following will take the average of a sequence of
      numbers.</para>

      <programlisting>object template function-test;

function average = {

  # Can't take an average without at least one value.
  if (ARGC == 0) {
    error('at least one argument must be given to average()');
  };

  # Iterate over all of the values and keep running sum.
  sum = 0.0;
  foreach (key; value; ARGV) {

    # Ensure that the argument is a number.
    if (! is_number(value) ) {
      error('non-numeric value encountered: ' + to_string(value));
    };
    sum = sum + value;
  };

  # Now give back the average.
  sum/ARGC;
};

'/result' = average(1, 2.5, 3, 5);</programlisting>

      <screen>$ panc --xml-style=text function-test.tpl 
$ cat function-test.txt 
+-profile
        $ result : (double) '2.875'</screen>

      <para>Functions are commonly used to perform some common algorithm or to
      do some validation. If the function is used for validation, then the
      function must return a boolean value. Note that all variables within the
      scope of a function are local to the function and cannot influence (or
      be influenced by) variables of the same name at other levels of the call
      stack.</para>
    </section>

    <section>
      <title>Flow Control</title>

      <para>In the DML, there are three expressions that can alter the normal
      sequential flow of execution: an <literal>if</literal> expression for
      branching, a <literal>while</literal> expression for looping, and a
      <literal>foreach</literal> expression for iteration. All of these are
      expressions that return a value. The value of each expression is the
      value of the last expression evaluated in the <literal>if</literal>,
      <literal>while</literal>, or <literal>foreach</literal> block. If the
      block is never executed, then the expression returns
      <literal>undef</literal>.</para>

      <para>The syntax for the <literal>if</literal> and
      <literal>while</literal> expressions are the same as in most programming
      languages. The syntax for the <literal>foreach</literal> expression
      requires an example:</para>

      <programlisting>object template foreach-test;

'/nlist-result' = {
  result = '';

  x = nlist('a', 1, 'b', 2, 'c', 3);

  foreach (key; value; x) {
    result = result + key + " -&gt; " + to_string(value) + "    ";
  };

  result;
};

'/list-result' = {
  result = '';

  y = list('alpha', 'beta', 'gamma');

  foreach (key; value; y) {
    result = result + to_string(key) + " -&gt; " + value + "    ";
  };

  result;
};</programlisting>

      <screen>$ panc --xml-style=text foreach-test.tpl 
$ cat foreach-test.txt 
+-profile
        $ list-result : (string) '0 -&gt; alpha    1 -&gt; beta    2 -&gt; gamma    '
        $ nlist-result : (string) 'a -&gt; 1    b -&gt; 2    c -&gt; 3    '</screen>

      <para>The <literal>foreach</literal> expression iterates over all of the
      children of the given resource, <varname>x</varname> and
      <varname>y</varname> in this example. For each child, the iteration
      variables (<varname>key</varname> and <varname>value</varname> here) are
      assigned the key/index and value of the child. Any valid names can be
      used for the iteration variables.</para>
    </section>

    <section>
      <title>Exercises</title>

      <orderedlist>
        <listitem>
          <para>Define a function that pushes a value on the end of a list.
          What happens if the list does not exist?</para>
        </listitem>

        <listitem>
          <para>Define a function that pushes a value on the end of
          <varname>SELF</varname>. What happens if the list does not exist? If
          the function does not work in this case, can you create a version
          that does?</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section>
    <title>Software Configuration</title>

    <para>On a machine managed by quattor, a daemon accepts notifications of
    configuration changes and then runs a set of "components" to affect those
    changes on the client. A component is simply a script that reads
    configuration information from the machine profile and then makes
    appropriate changes to the services running on the client. This includes
    starting, stopping, or restarting services as appropriate. Although it
    would be possible to create a single component that handles all of the
    machine configuration, this is neither scalable nor maintainable. Usually,
    a single component is responsible for a single, low-level service.</para>

    <para>In our scenario, there will be four components to configure: NFS,
    Torque, users, and firewall. The author of a component defines an
    appropriate configuration schema for the service and provides that schema
    via a pan language template. System administrators can then use that
    schema to set the service parameters via the pan language.</para>

    <section>
      <title>Components</title>

      <para>Components are built on a common skeleton and share some common
      parameters. Our reduced example will have an flag to indicate if a
      component is active and lists of dependencies. An overly simplistic
      schema might be the following:</para>

      <programlisting>type component = extensible {
  active : boolean = true
  pre ? string[]
  post ? string[]
};</programlisting>

      <para>A series of components could be bound to a particular part of the
      configuration tree. The usual schema used with quattor puts the
      components at <literal>/software/components/</literal> as an nlist; the
      bind statement to accomplish this is:</para>

      <programlisting>bind '/software/components' = component{};</programlisting>

      <para>Each component is identified by a unique key in this nlist.</para>

      <para>The <literal>extensible</literal> keyword on the record definition
      is extremely important. We expect each component to define additional
      parameters specific to the service it treats. Without the
      <literal>extensible</literal> keyword, the pan compiler would only allow
      the three children that are explicitly defined in the component type
      definition; the <literal>extensible</literal> keyword allows other
      children to exist.</para>

      <para>The above definition is overly simplistic because it does not
      validate the component's values very well. The active flag is fine;
      however, the pre- and post-dependencies should be limited to other
      active components specified in the configuration. Similarly, any
      additional parameters should be validated as much as possible to avoid
      having invalid parameters used to configure services. The next chapter
      will concentrate on the more advanced validation features available in
      the pan language.</para>
    </section>

    <section>
      <title>NFS Component Schema</title>

      <para>The Network File System (NFS) is a service that allows a machine
      to export certain paths that can then be mounted by other machines
      within their file systems. Correspondingly, there are two parts of the
      NFS configuration: one part for a server that exports paths and one part
      for the client that mounts those remote file systems. Note that any
      given machine can be a client, server, or both. The following schema
      captures the parameters needed for NFS configuration:</para>

      <programlisting># Type that defines path and authorized host for NFS server export.
type nfs_exports = {
  'path' : string
  'authorized_host' : string
};

# Type containing parameters to mount remote NFS volume.                        
type nfs_mounts = {
  'host' : string
  'path' : string           
  'mountpoint' : string
};

# Allows lists of NFS exports and NFS mounts (both optional).
type config_nfs = {
  include component
  'exports' ? nfs_exports[]
  'mounts'  ? nfs_mounts[]   
};</programlisting>

      <para>Assuming the <type>component</type> type has been defined and
      bound to <literal>/software/components</literal> as an nlist and the
      <type>config_nfs</type> type has been defined, the following will ensure
      that the <literal>/software/components/nfs</literal> path meets both the
      <type>component</type> and <type>config_nfs</type> types:</para>

      <programlisting>bind '/software/components/nfs' = config_nfs;</programlisting>

      <para>Note that with the above bind, this implies that this path has two
      type definitions associated with it: <type>component</type> and
      <type>config_nfs</type>. The pan language allows multiple types to be
      defined to a path and enforces all of them. That is, all of the types
      bound to a path must be valid for the configuration as a whole to be
      valid. Be careful not to assign multiple incompatible types to the same
      path. For example, the following will never lead to a validated
      configuration:</para>

      <programlisting>object template never-valid;

bind '/result' = string;
bind '/result' = boolean;

'/result' = 'OK';</programlisting>

      <para>because either one or the other of the bound types will fail.
      Real-world conflicts of this type are usually more complicated but, at
      the most basic level, arise because of incompatible primitive types
      being assigned to the same path.</para>

      <para>As can be seen above, allowing multiple types to be bound to the
      same path permits pan to have functionality similar to object
      inheritance. In reality, this is a "duck" typing system that simply
      checks that all of the bound types are simultaneously satisfied.</para>
    </section>

    <section>
      <title>Torque Component Schema</title>

      <para>Torque is a commonly-used batch system. Like the NFS
      configuration, there are client and server aspects to running Torque.
      One difference, however, is that a client can be associated with only
      one server. The server configuration consists of a set of queues and
      list of client nodes associated with the server. The client
      configuration simply indicates if the client's state and the name of the
      server. The schema is:</para>

      <programlisting># Torque server information.
type torque_server = {
  'queues' : string[1..]
  'workers' ? string[]
};

# Torque client information.
type torque_client = {
  'server' : string
  'state' : string with match(SELF, 'open|closed|drain');
};

# Overall configuration.
type config_torque = {
  include component
  'server_params' ? torque_server
  'client_params' ? torque_client
};</programlisting>

      <para>This can be bound to part of the configuration schema like was
      done for NFS. In our example, will will use the path
      <literal>/system/components/torque</literal>.</para>
    </section>

    <section>
      <title>Schemas for Users and a Firewall</title>

      <para>In a complete system there are a large number of services that
      need to be configured. Many of these services share common needs for
      low-level configuration of things like the users and open ports on the
      firewall. These are included just to show some of the best practices
      when organizing configuration templates. The simplified schemas
      are:</para>

      <programlisting># Simple user configuration component.
type config_users = {
  include component
  'uid' : long(0..){}
};

# Simple firewall configuration component.
type config_firewall = {
  include component
  'open' : long(0..)[]
};</programlisting>

      <para>This allows usernames to be associated to a given UID and to
      specify open ports in the firewall.</para>
    </section>

    <section>
      <title>Component Configuration Organization</title>

      <para>Pan puts very few constraints on the organization of the
      configuration information for components. Nonetheless, some best
      practices have arisen with use of the system and now almost every
      component exposes two pan templates: <filename>schema.tpl</filename> and
      <filename>config.tpl</filename>. The schema template contains a
      component's schema definition and any associated validation functions.
      The other file contains the default configuration for the component,
      such as standard dependencies, global variables, etc. The schema file
      for Torque might look like the following:</para>

      <programlisting>declaration template component/torque/schema;

include { 'quattor/structure_component' };

# Torque server information.
type torque_server = {
  'queues' : string[1..]
  'workers' ? string[]
};

# Torque client information.
type torque_client = {
  'server' : string
  'state' : string with match(SELF, 'open|closed|drain');
};

# Overall configuration.
type config_torque = {
  include component
  'torque_user' ? string
  'server_params' ? torque_server
  'client_params' ? torque_client
};</programlisting>

      <para>and the associate default configuration file:</para>

      <programlisting>unique template component/torque/config;

# Define the schema for the Torque configuration.
include { 'component/torque/schema' };

# Define some default port numbers. 
variable TORQUE_CLIENT_PORT ?= 9999;
variable TORQUE_SERVER_port ?= 9998;

# Bind the schema to a particular place in the configuration tree.
bind '/software/components/torque' = config_torque;

# Set the component to be active by default.
'/software/components/torque/active' ?= true;</programlisting>

      <para>To ensure that the necessary schema is defined and to ensure that
      all of the default actions have been taken, it is wise to always include
      the <filename>config.tpl</filename> file before each block of Torque
      configuration statements. Notice that these templates are defined as a
      <literal>declaration</literal> and <literal>unique</literal> templates,
      respectively, to avoid any performance penalty for including these files
      repeatedly. Usually a system administrator would only include the
      <filename>config.tpl</filename> file directly.</para>

      <para>Distributions of templates usually go one step further and define
      templates for common service configurations. For example, one could
      create a Torque server that does the default configuration for a machine
      running a Torque server. Take the following example:</para>

      <programlisting>unique template service/torque/server;

include { 'component/torque/config' };

# Change the default port, setup the queues, and identify the worker nodes.
variable TORQUE_SERVER_PORT = 1212;
'/software/components/torque/server_params/queues' = list('short', 'medium', 'long');
'/software/components/torque/server_params/workers' = list('worker1.example.org', 'worker2.example.org');

# Open the correct port on the firewall. 
include { 'component/firewall/config' };
'/software/components/firewall/open' = {
  SELF[length(SELF)] = TORQUE_SERVER_PORT;
};

# Setup the user for torque.
include { 'component/users/config' };
'/software/components/users/uid/torque_mgr' = 1000;</programlisting>

      <para>This template would do all that is necessary to configure a Torque
      server, including the configuration of the low-level services. A system
      administrator wanting to use this, would then create an object template
      like the following:</para>

      <programlisting>object template torque-server;

# ... some machine hardware configuration ...

# Run a Torque server on this machine.
include { 'service/torque/config' };

# ... inclusion of other high-level service configurations ...</programlisting>

      <para>Using the conventions described above allows maximum reuse of the
      configuration information and makes it easy to mix-and-match high-level
      services for a particular object template.</para>
    </section>
  </section>

  <section>
    <title>General Validation</title>

    <para>The greatest strength of the pan language is the ability to do
    detailed validation of configuration parameters, of correlated parameters
    within a machine profile, and of correlated parameters
    <emphasis>between</emphasis> machine profiles. Although the validation can
    make it difficult to get a particular machine profile to compile, the time
    spent getting a valid machine configuration before deployment more than
    makes up for the time wasted debugging a bad configuration that has been
    deployed.</para>

    <para>Simple validation through the validation of primitive properties and
    simple resources has already been covered when discussing the pan type
    definition features. This chapter deals with more complicated
    scenarios.</para>

    <section>
      <title>Advanced Parameter Validation</title>

      <para>Often there are cases where the legal values of a parameter cannot
      be expressed as a simple range. The pan language allows you to attach
      arbitrary validation code to a type definition. The code is attached to
      the type definition using the <literal>with</literal> keyword. Consider
      the following examples:</para>

      <programlisting>type even_positive_long = long(1..) with (SELF % 2 == 0);
type machine_state_enum = string with match(SELF, 'open|closed|drain');
type ip = string with is_ipv4(SELF);</programlisting>

      <para>The validation code must return the boolean value
      <literal>true</literal>, if the associated value is correct. Returning
      any other value or raising an error with the <function>error</function>
      function will cause the build of the machine configuration to
      abort.</para>

      <para>Simple constraints are often written directly with the type
      statement; more complicated validation usually calls a separate
      function. The third line in the example above calls the function
      <function>is_ipv4</function>. This is a user-defined function that could
      look like:</para>

      <programlisting>function is_ipv4 = {
  terms = split('\.', ARGV[0]);
  foreach (index; term; terms) {
    i = to_long(term);
    if (i &lt; 0 || i &gt; 255) {
      return(false);
    };
  };
  true;
};</programlisting>

      <para>A real version of this function would probably do a great deal
      more checking of the value and probably raise errors with more intuitive
      error messages.</para>
    </section>

    <section>
      <title>Validation of Correlated Configuration Parameters</title>

      <para>Often the correct configuration of a machine requires that
      configuration parameters in different parts of the configuration are
      correlated. One example is the validation of the pre- and
      post-dependencies of the component configuration. It makes no sense for
      one component to depend on another one that is not defined in the
      configuration or is not active.</para>

      <para>The following validation function accomplishes such a check,
      assuming that the components are bound to
      <literal>/software/components</literal>:</para>

      <programlisting>function valid_component_list = {

  # ARGV[0] should be the list to check.

  # Check that each referenced component exists.
  foreach (k; v; ARGV[0]) {

    # Path to the root of the named component.
    path = '/software/components/' + v;

    if (!exists(path)) {
      error(path + ' does not exist');
    } else {

      # Path to the active flag for the named component.
      active_path = path + '/active';

      if (!(is_defined(active_path) &amp;&amp; value(active_path))) {
        error('component ' + v + ' isn't active');
      };

    };

  };

};

type component_list = string[] with valid_component_list(SELF);

type component = extensible {
  active : boolean = true
  pre ? component_list
  post ? component_list
};</programlisting>

      <para>It also defines a <type>component_list</type> type and uses this
      for a better definition of a the <type>component</type> type. This will
      get run on anything that is bound to the component type, directly or
      indirectly. Note how the function looks at other values in the
      configuration by creating the path and looking up the values with the
      <function>value</function> function.</para>

      <para>The above function works but has one disadvantage: it will only
      work for components defined below
      <literal>/software/components</literal>. If the list of components is
      defined elsewhere, then this schema definition will have to be modified.
      One can usually avoid this by applying the validation to a common
      parent. In this case, we can add the validation to the parent.</para>

      <programlisting>function valid_component_nlist = {

  # Loop over each component.
  foreach (name; component; SELF) {

    if (exists(component['pre'])) {
      foreach (index; dependency; component['pre']) {
        if (!exists(SELF['dependency']['active'] ||
             SELF['dependency']['active'])) {
          error('non-existant or inactive dependency: ' + dependency);
        };
      };
    };

    # ... same for post ...

  };

};


type component = extensible {
  active : boolean = true;
  pre ? string[]
  post ? string[]
};

type component_nlist = component{} with valid_component_nlist(SELF);</programlisting>

      <para>This will accomplish the same validation, but will be independent
      of the location in the tree. It is, however, significantly more
      complicated to write and to understand the validation function. In the
      real world, the added complexity must be weighed against the likelihood
      that the type will be re-located within the configuration tree.</para>

      <para>The situation often arises that you want to validate a parameter
      against other siblings in the machine configuration tree. In this case,
      we wanted to ensure that other components were properly configured; to
      know that we needed to search "up and over" in the machine
      configuration. The pan language does not allow use of relative paths for
      the <function>value</function> function, so the two options are those
      presented here. Use an absolute path and reconstruct the paths or put
      the validation on a common parent.</para>
    </section>

    <section>
      <title>Cross-Machine Validation</title>

      <para>Another common situation is the need to validate machine
      configurations against each other. This often arises in client/server
      situations. For NFS, for instance, one would probably like to verify
      that a network share mounted on a client is actually exported by the
      server. The following example will do this:</para>

      <programlisting># Determine that a given mounted network share is actually
# exported by the server.
function valid_export = {

  info = ARGV[0];
  myhost = info['host'];
  mypath = info['path'];

  exports_path = host + ':/software/components/nfs/exports';
  
  found = false;
  if (path_exists(exports_path)) {

    exports = value(exports_path);

    foreach (index; einfo; exports) {
      if (einfo['authorized_host'] == myhost &amp;&amp;
          einfo['path'] == mypath) {
        found = true;
      };
    };

  };
  found;
};

# Type that defines path and authorized host for NFS server export.
type nfs_exports = {
  'path' : string
  'authorized_host' : string
};

# Type containing parameters to mount remote NFS volume.                        
type nfs_mounts = {
  'host' : string
  'path' : string           
  'mountpoint' : string
} with valid_export(SELF);

# Allows lists of NFS exports and NFS mounts (both optional).
type config_nfs = {
  include component
  'exports' ? nfs_exports[]
  'mounts'  ? nfs_mounts[]   
};</programlisting>

      <para>To do this type of validation, the full external path must be
      constructed for the <function>value</function> function. This has the
      same disadvantage as above in that if the schema is changed the function
      definition needs to be altered accordingly. The above code also assumes
      that the machine profile names are equivalent to the hostname. If
      another convention is being used, then the hostname will have to be
      converted to the corresponding machine name.</para>

      <para>It is worth noting that all of the validation is done
      <emphasis>after</emphasis> the machine configuration trees are built.
      This allows circular validation dependencies to be supported. That is,
      clients can check that they are properly included in the server
      configuration and the server can check that its clients are configured.
      A batch system is a typical example where this circular cross-validation
      is useful.</para>
    </section>

    <section>
      <title>Exercises</title>

      <orderedlist>
        <listitem>
          <para>Devise a schema for a client/server system that you are
          familiar with.</para>
        </listitem>

        <listitem>
          <para>Add validation for all of the parameters.</para>
        </listitem>

        <listitem>
          <para>Create the <filename>config.tpl</filename> and
          <filename>schema.tpl</filename> files for this system.</para>
        </listitem>

        <listitem>
          <para>Create client and server files for this service. Incorporate
          them in object templates and ensure that they behave as
          expected.</para>
        </listitem>

        <listitem>
          <para>Add validation to verify the client and server machine
          configurations against each other.</para>
        </listitem>

        <listitem>
          <para>Create the validation functions necessary to do the circular
          cross-validation described for the Torque batch system.</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section>
    <title>Conclusions</title>

    <para>This tutorial covered the highlights of the pan language. After
    finishing this tutorial, you should be able to create and maintain a site
    configuration written in the pan language. This tutorial, however, did not
    cover any of the configuration conventions of a particular community. Ask
    others in the community about common conventions (e.g. on the Quattor
    mailing list or the Quattor Working Group (QWG) wiki); links to other
    sources of information can be found on the Quattor web site. You can also
    find more information about the pan language and the pan compiler in the
    other documents distributed with the compiler.</para>
  </section>
</article>
