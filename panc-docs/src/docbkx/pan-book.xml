<?xml version="1.0" encoding="UTF-8"?>
<book version="5.0" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:m="http://www.w3.org/1998/Math/MathML"
      xmlns:html="http://www.w3.org/1999/xhtml"
      xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>Pan Configuration Language</title>

    <subtitle><?eval ${project.version}?></subtitle>

    <author>
      <personname><firstname>Charles</firstname><surname>Loomis</surname></personname>

      <email>loomis@lal.in2p3.fr</email>

      <affiliation>
        <orgname>Centre National de la Recherche Scientifique (CNRS)</orgname>
      </affiliation>
    </author>

    <pubdate><?eval ${buildTimestamp}?></pubdate>

    <productnumber><?eval ${project.version}?></productnumber>

    <date><?eval ${buildTimestamp}?></date>

    <copyright>
      <year>2013</year>

      <holder>Centre National de la Recherche Scientifique (CNRS)</holder>
    </copyright>

    <legalnotice>
      <para>This work is licensed under the Creative Commons Attribution 3.0
      Unported License. To view a copy of this license, visit <uri
      xlink:href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</uri>
      or send a letter to Creative Commons, 171 Second Street, Suite 300, San
      Francisco, California, 94105, USA.</para>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentwidth="3cm" fileref="images/by.png"
                     format="PNG" valign="middle" width="15%"></imagedata>
        </imageobject>

        <imageobject>
          <imagedata align="center" contentwidth="3cm" fileref="images/by.svg"
                     format="SVG" valign="middle" width="15%"></imagedata>
        </imageobject>
      </mediaobject>
    </legalnotice>

    <mediaobject>
      <imageobject>
        <imagedata align="center" contentwidth="10cm"
                   fileref="images/quattor_logo.png" format="PNG"></imagedata>
      </imageobject>

      <imageobject>
        <imagedata align="center" contentwidth="10cm" depth=""
                   fileref="images/quattor_logo.svg" format="SVG"></imagedata>
      </imageobject>

      <imageobject>
        <imagedata align="center" contentwidth="10cm"
                   fileref="images/quattor_logo.pdf" format="PDF"></imagedata>
      </imageobject>
    </mediaobject>
  </info>

  <preface>
    <title>Preface</title>

    <section>
      <title>Organization</title>

      <para>This book is intended to act as both a reference guide for the pan
      configuration language as well as a tutorial on using the associated
      compiler. The first chapter introduces the language and guides you
      through a basic installation of the compiler. The following chapter
      provides a simplified, real-world example to show the major features of
      the pan language for site configuration. Chapters 3-8 provide a detailed
      description of the pan language and act as a reference for it. Chapters
      9-11 provide information about advanced features and best practices when
      using the language. Finally, Chapter 12 gives some information about
      troubleshooting problems that can arise when using the compiler and
      language. The appendices provide detailed information on installing and
      using the compiler in various environments as well as detailed
      information on the pan commands and functions.</para>
    </section>

    <section>
      <title>Typographic Conventions</title>

      <table>
        <title>Typographic Conventions</title>

        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="1*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <tbody>
            <row>
              <entry><filename>filename</filename></entry>

              <entry>References to files are typeset in this style. In this
              book, these are usually references to configuration
              templates.</entry>
            </row>

            <row>
              <entry>command</entry>

              <entry>Commands to be executed from the command line are typeset
              in this style. This is usually a direct or indirect invocation
              of the pan configuration language compiler.</entry>
            </row>

            <row>
              <entry><literal>keyword</literal></entry>

              <entry>Pan configuration language keywords are typeset in this
              style. They represent the language's reserved words and should
              appear in configuration files exactly as written.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </preface>

  <chapter>
    <title>Getting Started</title>

    <para>The pan configuration language allows system administrators to
    define simultaneously a site configuration and a schema for validation. As
    a core component of the Quattor fabric management toolkit, the pan
    compiler translates this high-level site configuration to a
    machine-readable representation, which other tools can then use to enact
    the desired configuration changes.</para>

    <section>
      <title>Configuration Language</title>

      <para>The pan language was designed to have a simple, human-friendly
      syntax. In addition, it allows more rigorous validation via its flexible
      data typing features when compared to, for instance, XML and
      XMLSchema.</para>

      <para>The name "compiler" is actually a misnomer, as the pan compiler
      does much more than a simple compilation. The processing progresses
      through five stages:</para>

      <variablelist>
        <varlistentry>
          <term>compilation</term>

          <listitem>
            <para>Compile each individual template (file written in the pan
            configuration language) into a binary format.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>execution</term>

          <listitem>
            <para>The statements the templates are executed to generate a
            partial tree of configuration information. The generated tree
            contains all configuration information directly specified by the
            system administrator.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>insertion of defaults</term>

          <listitem>
            <para>A pass is made through the tree of configuration information
            during which any default values are inserted for missing elements.
            The tree of configuration information is complete after this
            stage.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>validation</term>

          <listitem>
            <para>The configuration information is frozen and all standard and
            user-specified validation is done. Any invalid values or
            conditions will cause the processing to abort.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>serialization</term>

          <listitem>
            <para>Once the information is complete and valid, it is serialized
            to a file. Usually, this file is in an XML format, but other
            representations are available as well.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>The pan compiler runs through these stages for each "object"
      template. Usually there is one object template for each physical
      machine; although with the rise of virtualization, it may be one per
      logical machine.</para>
    </section>

    <section>
      <title>Benefits</title>

      <para>Using the pan language and compiler has the following
      benefits:</para>

      <itemizedlist>
        <listitem>
          <para>Declarative language allows easier merging of configurations
          from different administrators.</para>
        </listitem>

        <listitem>
          <para>Encourages organization of configuration by service and
          function to allow sharing of configurations between machines and
          sites.</para>
        </listitem>

        <listitem>
          <para>Provides simple syntax for definition of configuration
          information and validation.</para>
        </listitem>

        <listitem>
          <para>Ensures a high-level of validation before configurations are
          deployed, avoiding interruptions in services and wasted time from
          recovery.</para>
        </listitem>
      </itemizedlist>

      <para>The language and compiler are intended to be used with other tools
      that manage the full set of configuration files and that can affect the
      changes necessary to arrive at the desired configuration. The Quattor
      toolkit provides such tools, although the compiler can be easily used in
      conjunction with others.</para>
    </section>

    <section>
      <title>Download and Installation</title>

      <para>The pan compiler can be invoked via the Unix (Linux) command line,
      ant, or maven. The easiest for the simple examples in this book is the
      command line interface. (See Appendix A for installation instructions
      for all the execution methods.) Locate and download the latest version
      of the pan tarball and untar this into a convenient directory. You can
      find the packaged versions of the compiler in the Quattor project space
      on SourceForge.</para>

      <para>The pan compiler requires a Java Runtime Environment (JRE) or Java
      Development Kit (JDK) 1.5 or later. If you will just be running a binary
      version of the pan compiler, the JRE is sufficient; compiling the
      sources will require the JDK. Use a complete, certified version of the
      Java Virtual Machine; in particular avoid the GNU Java Compiler (GJC) as
      the pan compiler will not run correctly with it.</para>

      <para>To use the compiler from the command line, you must make it
      accessible from the path.</para>

      <screen>$ export PANC_HOME=/panc/location
$ export PATH=$PANC_HOME/bin:$PATH</screen>

      <para>The above will work for Bourne shells; adjust the command for the
      shell that you use. Change the value of <varname>PANC_HOME</varname> to
      the directory where the pan compiler was unpacked.</para>
    </section>

    <section>
      <title>Validating the Installation</title>

      <para>Once you have installed the compiler, make sure that it is working
      correctly by using the command:</para>

      <screen>$ panc --help</screen>

      <para>This gives a complete list of all of the available options. If the
      command fails, review the installation instructions.</para>
    </section>

    <section>
      <title>Invoking the Pan Compiler</title>

      <para>Now create a file (called a "template") named
      <filename>hello_world.pan</filename> that contains the following:</para>

      <programlisting>object template hello_world;
'/message' = 'Hello World!';</programlisting>

      <para>Compile this template into the default XML representation and look
      at the output.</para>

      <screen>$ panc hello_world.pan

$ cat hello_world.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;nlist format="pan" name="profile"&gt;
    &lt;string name="message"&gt;Hello World!&lt;/string&gt;
&lt;/nlist&gt;</screen>

      <para>The output should look similar to what is shown above. As you can
      see the generated information has a simple structure: a top-level
      element of type <type>nlist</type>, named "profile" with a single
      <type>string</type> child, named "message". The value of the "message"
      is "Hello World!". If the output format is not specified, the default is
      the "pan" XML style shown above, in which the element names are the pan
      primitive types and the name attribute corresponds to the name of the
      field in the pan template.</para>

      <para>The pan compiler can generate output in three additional formats:
      json, text, and dot. The following shows the output for the json format
      that was written to the <filename>hello_world.json</filename>
      file.</para>

      <screen>$ panc --formats json hello_world.pan 

$ cat hello_world.json 
{
  "message": "Hello World!"
} </screen>

      <para>In this book, the most convenient representation is the text
      format. This provides a clean representation of the configuration tree
      in plain text.</para>

      <screen>$ panc --formats text hello_world.pan

$ cat hello_world.txt
+-profile
  $ message : (string) 'hello'</screen>

      <para>The output file is named <filename>hello_world.txt</filename>. It
      provides the same information as the other formats, but is easier to
      read.</para>

      <para>The last style is the "dot" format.</para>

      <screen>$ panc --formats dot hello_world.pan

$ cat hello_world.dot
digraph "profile" {
bgcolor = beige
node [ color = black, shape = box, fontname=Helvetica ]
edge [ color = black ]
"/profile" [ label = "profile" ]
"/profile/message" [ label = "message\n'Hello World!'" ]
"/profile" -&gt; "/profile/message"
}</screen>

      <para>Although the text is not very enlightening by itself, it can be
      used by <link xlink:href="http://www.graphviz.org/">Graphviz</link> to
      generate a graph of the configuration. Processing the above file with
      Graphviz produces the image shown in <xref
      linkend="fig-hello" />.</para>

      <figure xml:id="fig-hello">
        <title>Graph of configuration produced by
        <filename>hello_world.pan</filename>.</title>

        <mediaobject>
          <alt>Graph of configuration produced by the file
          hello_world.pan.</alt>

          <imageobject role="html">
            <imagedata align="center" fileref="images/hello.png" format="PNG"
                       valign="middle"></imagedata>
          </imageobject>

          <imageobject role="fo">
            <imagedata align="center" fileref="images/hello.svg" format="SVG"
                       valign="middle"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </chapter>

  <chapter>
    <title>A Whirlwind Tour</title>

    <para>This tour will highlight the major features of the pan language by
    showing how the configuration for a batch system for asynchronous handling
    of jobs could be described with the pan language. The fictitious,
    simplified batch system used here gives you the flavor of the development
    process and common pan features. The description of a real batch system
    would contain significantly more parameters and services.</para>

    <section>
      <title>Batch System Description</title>

      <para>A batch system provides a set of resources for asynchronous
      execution of jobs (scripts) submitted by users. The batch system (or
      cluster) consists of:</para>

      <variablelist>
        <varlistentry>
          <term>Server (or head node)</term>

          <listitem>
            <para>A machine containing a service for accepting job requests
            from users and a scheduler for dispatching those jobs to available
            workers.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Workers</term>

          <listitem>
            <para>Machines that accept jobs from the server, execute them, and
            then return the results to the server.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Users send a script containing the job description to the server.
      The server then queues the request for later execution. The scheduler
      periodically checks the queued jobs and resources, sending a queued job
      for execution on a worker if one is available. The worker executes the
      job it has been given and keeps the server informed about the state of
      the job. At the end of the job, results are returned to the server. The
      user can interact with the server to determine the status of jobs and to
      retrieve the output of completed jobs.</para>

      <para>For our simplified batch system, we want to create a set of
      parameters that describe the configuration. For many real services, the
      configuration schema used in pan will closely mirror the configuration
      file(s) of the service. In our case we will create a configuration
      schema based on the above description.</para>

      <para>The server controls a set of workers and manages jobs via a set of
      queues. Each queue is named, has a CPU limit, and can be enabled or
      disabled. Each node also has a name, participates in one or more queues,
      and has a set of capabilities (e.g. a particular software license is
      available, has a fast network connection, etc.).</para>

      <para>The worker needs to know with which server to communicate. Each
      worker will also have a flag to indicate if the worker is enabled or
      disabled.</para>
    </section>

    <section>
      <title>Naive Configuration</title>

      <para>Given the previous description, a pan language configuration for
      both the batch server and one batch worker can easily be created. We
      must create an object template for each machine in order to have the
      machine descriptions created during the compilation. Create the file
      <filename>server.example.org.pan</filename> with the following
      contents:</para>

      <programlisting>object template server.example.org;

'/batch/server/nodes/worker01.example.org/queues' 
    = list('default');

'/batch/server/nodes/worker01.example.org/capabilities' 
    = list('sw-license', 'fast-network');

'/batch/server/queues/default/maxCpuHours' = 1;
'/batch/server/queues/default/enabled' = true;</programlisting>

      <para>It is customary to use the machine name as the object template
      name. For this server, there is one worker node named
      'worker01.example.org' and one queue named 'default'. The worker node
      participates in the 'default' queue and has a couple of capabilities.
      The 'default' queue has a CPU limit of 1 hour.</para>

      <para>Create the file <filename>worker01.example.org.pan</filename> for
      the worker:</para>

      <programlisting>object template worker01.example.org;

'/batch/worker/server' = 'server.example.org';
'/batch/worker/enabled' = true;</programlisting>

      <para>This is part of the cluster controlled by the server
      'server.example.org' and is enabled.</para>

      <para>These templates can be compiled with the following command:</para>

      <screen>$ panc --formats text *.pan</screen>

      <para>which then produces the files
      <filename>server.example.org.txt</filename> and
      <filename>worker01.example.org.txt</filename>:</para>

      <screen>+-profile
  +-batch
    +-server
      +-nodes
        +-worker01.example.org
          +-capabilities
            $ 0 : (string) 'sw-license'
            $ 1 : (string) 'fast-network'
          +-queues
            $ 0 : (string) 'default'
      +-queues
        +-default
          $ maxCpuHours : (long) '1'</screen>

      <screen>+-profile
  +-batch
    +-worker
      $ enabled : (boolean) 'true'
      $ server : (string) 'server.example.org'</screen>

      <para>These generated files (or more likely their equivalents in XML)
      can then be used by tools to actually configure the machines and batch
      services appropriately.</para>
    </section>

    <section>
      <title>Using Namespaces and Includes</title>

      <para>The naive configuration shown in the previous section has a couple
      of problems. First, it will become tedious to maintain, especially if
      individual machines contain a mix of different services. Second, similar
      configurations would be duplicated between object templates, increasing
      the likelihood of errors. These problems can be eliminated by
      refactoring the configuration into separate templates and by organizing
      those templates into reasonable namespaces.</para>

      <para>As a first step in reorganizing the configuration, we pull out the
      batch server and worker configurations into separate
      <emphasis>ordinary</emphasis> templates. These configurations are put
      into <filename>services/batch-server.pan</filename> and
      <filename>services/batch-worker.pan</filename>, respectively.</para>

      <programlisting>template services/batch-server;

'/batch/server/nodes/worker01.example.org/queues' 
    = list('default');

'/batch/server/nodes/worker01.example.org/capabilities' 
    = list('sw-license', 'fast-network');

'/batch/server/queues/default/maxCpuHours' = 1;
'/batch/server/queues/default/enabled' = true;</programlisting>

      <programlisting>template services/batch-worker;

'/batch/worker/server' = 'server.example.org';
'/batch/worker/enabled' = true;</programlisting>

      <para>Note that these files are not object templates (i.e. there is no
      <literal>object</literal> modifier) and will not produce any output
      files themselves. Note also that they are namespaced; the relative
      directory of the template must match the path hierarchy in the file
      system. In this particular case, these both must appear in a
      <filename>services</filename> subdirectory.</para>

      <para>Object templates can also be namespaced; here we will put them
      into a <filename>profiles</filename> subdirectory. These object
      templates can then include configuration in other (non-object)
      templates. The contents of these profiles becomes:</para>

      <programlisting>object template profiles/server.example.org;

include 'services/batch-server';</programlisting>

      <programlisting>object template profiles/worker01.example.org;

include 'services/batch-worker';</programlisting>

      <para>Organizing the service configurations in this way makes it easy to
      include multiple services in a particular object template. If reasonable
      names are chosen, then the object template becomes self-documenting,
      listing the services included on the machine.</para>

      <para>The command to compile these object templates is slightly
      different:</para>

      <screen>$ panc --formats text profiles/*.pan</screen>

      <para>The output files by default will be placed next to the object
      template, so in this case they will be in the
      <filename>profiles</filename> subdirectory. You can verify that the
      reorganized configuration produces exactly the same configuration as the
      first example.</para>
    </section>

    <section>
      <title>Simple Typing</title>

      <para>Although the configuration is completely specified in the previous
      examples, it does not protect you from inappropriate values, for
      instance, specifying 'ON' for the boolean worker's
      <parameter>enabled</parameter> parameter or a negative number for the
      <parameter>maxCpuHours</parameter> parameter of a queue. The pan
      language has a number of primitive types, collections, and mechanisms
      for user-defined types.</para>

      <para>Create a file named <filename>services/batch-types.pan</filename>
      with the following content:</para>

      <programlisting>declaration template services/batch-types;<co
          xml:id="batch-types-declaration" />

type batch_capabilities<co xml:id="batch-types-batch_capabilities" /> = string[];

type batch_queue_list<co xml:id="batch-types-batch_queue_list" /> = string[1..];

type batch_node<co xml:id="batch-types-batch_node" /> = {
  'queues' : batch_queue_list
  'capabilities' ? batch_capabilities
};

type batch_queue<co xml:id="batch-types-batch_queue" /> = {
  'maxCpuHours' : long(0..)
  'enabled' : boolean
};

type batch_server<co xml:id="batch-types-batch_server" /> = {
  'nodes' : batch_node{}
  'queues' : batch_queue{}
};

type batch_worker<co xml:id="batch-types-batch_worker" /> = {
  'server' : string
  'enabled' : boolean
};</programlisting>

      <calloutlist>
        <callout arearefs="batch-types-batch_worker">
          <para>The <type>batch_worker</type> type defines a record (dict or
          hash with named children) for the worker configuration. The
          'enabled' flag is defined to be a boolean value. The 'server' is
          defined to be a string. For a real configuration, the server would
          likely be define to be a hostname or IP address with appropriate
          constraints.</para>
        </callout>

        <callout arearefs="batch-types-batch_server">
          <para>The <type>batch_server</type> type also defines a record with
          nodes and queues children. These are both defined to be dicts where
          the keys are the worker host name or the queue name, respectively.
          The notation <literal>mytype{}</literal> defines an dict.</para>
        </callout>

        <callout arearefs="batch-types-batch_queue" conformance="">
          <para>Type batch_queue type defines a record with the
          characteristics of a queue. Each queue can be enabled or disabled.
          The <parameter>maxCpuHours</parameter> is required to be a
          non-negative long value. The range specification
          <literal>(0..)</literal> limits the allowed values. Range limits
          like this apply to the numeric value for long and double types; it
          applies to the length for strings.</para>
        </callout>

        <callout arearefs="batch-types-batch_node">
          <para>Type batch_node again defines a record for a single node. The
          node description contains a list of queues and a list of
          capabilities. In this case, the record specifier uses a question
          mark ('?') indicating that the field is optional; if the record
          specifier uses a colon (':') then the field is required.</para>
        </callout>

        <callout arearefs="batch-types-batch_queue_list">
          <para>Type <type>batch_queue_list</type> is an alias for a list of
          strings, but also contains a range limitation
          <literal>[1..]</literal>. This range limitation means that the list
          must contain at least one element.</para>
        </callout>

        <callout arearefs="batch-types-batch_capabilities">
          <para>Type batch_capabilities is just an alias for a list of
          strings. It is a convenience type used to make the field description
          clearer.</para>
        </callout>

        <callout arearefs="batch-types-declaration">
          <para>The template <literal>declaration</literal> uses the
          declaration modifier. This means that the template will only be
          executed once during the build of a particular machine profile. It
          also limits the content of the template to variable, function, and
          type definitions.</para>
        </callout>
      </calloutlist>

      <para>A complete set of types is now available for the batch
      configuration, but at this point, none of these types have been attached
      to a part of the configuration. The <literal>bind</literal> statement
      associates a particular type to a path. Note that a single path can have
      multiple type declarations associated with it. For the batch
      configuration, the <filename>services/batch-server.pan</filename> and
      <filename>services/batch-worker.pan</filename> have had a
      <literal>bind</literal> statement added.</para>

      <programlisting>template services/batch-server;

include 'services/batch-types';

bind '/batch/server' = batch_server;

'/batch/server/nodes/worker01.example.org/queues' 
    = list('default');

'/batch/server/nodes/worker01.example.org/capabilities' 
    = list('sw-license', 'fast-network');

'/batch/server/queues/default/maxCpuHours' = 1;
'/batch/server/queues/default/enabled' = true;</programlisting>

      <programlisting>template services/batch-worker;

include 'services/batch-types';

bind '/batch/worker' = batch_worker;

'/batch/worker/server' = 'server.example.org';
'/batch/worker/enabled' = true;</programlisting>

      <para>Types have been bound to two paths with these
      <literal>bind</literal> statements. If any of the content does not
      conform to the specified types, then an error will occur during the
      compilation. Note that we have not limited the values for paths other
      than these two paths and their children. Configuration in other paths
      can be added without being subject to these type definitions. A global
      schema can be defined by binding a type definition to the root path
      '/'.</para>
    </section>

    <section>
      <title>Default Values</title>

      <para>Very often configuration parameters can have reasonable default
      values, avoiding the need to specify them explicitly within a machine
      profile. The pan type system allows default values to be defined and
      then inserted into a machine configuration when necessary. The following
      is a modified version of the <filename>batch-types.pan</filename> file
      with default values added.</para>

      <programlisting>declaration template services/batch-types;

type batch_capabilities = string[];

type batch_queue_list = string[1..];

type batch_node = {
  'queues' : batch_queue_list = list('default') <co
          xml:id="batch-types-default-node-queues" />
  'capabilities' ? batch_capabilities
};

type batch_queue = {
  'maxCpuHours' : long(0..) = 1 <co xml:id="batch-types-default-cpuhours" />
  'enabled' : boolean = true <co xml:id="batch-types-default-queue-enabled" />
};

type batch_server = {
  'nodes' : batch_node{}
  'queues' : batch_queue{} = dict('default', dict()) <co
          xml:id="batch-types-default-queues" />
};

type batch_worker = {
  'server' : string
  'enabled' : boolean = true <co xml:id="batch-types-default-worker-enabled" />
};</programlisting>

      <calloutlist>
        <callout arearefs="batch-types-default-node-queues">
          <para>If the queue list for a node is not specified, then assume
          that the node will participate in the 'default' queue. That is, the
          default value is a one-element list containing the string
          'default'.</para>
        </callout>

        <callout arearefs="batch-types-default-cpuhours">
          <para>Default to 1 CPU-hour for the queue execution limit.</para>
        </callout>

        <callout arearefs="batch-types-default-queue-enabled">
          <para>By default, a queue will be enabled.</para>
        </callout>

        <callout arearefs="batch-types-default-queues">
          <para>If no queues are specified, then provide an dict containing
          only a queue definition for the 'default' queue. Note that the
          actual queue parameters are provided by the type definition
          <type>batch_queue</type>.</para>
        </callout>

        <callout arearefs="batch-types-default-worker-enabled">
          <para>By default, a worker will be enabled.</para>
        </callout>
      </calloutlist>

      <para>Using these default values, then simplifies the configuration
      templates <filename>services/batch-server.pan</filename> and
      <filename>services/batch-worker.pan</filename>.</para>

      <programlisting>template services/batch-server;

include 'services/batch-types';

bind '/batch/server' = batch_server;

'/batch/server/nodes/worker01.example.org/capabilities' 
    = list('sw-license', 'fast-network');</programlisting>

      <programlisting>template services/batch-worker;

include 'services/batch-types';

bind '/batch/worker' = batch_worker;

'/batch/worker/server' = 'server.example.org';</programlisting>

      <para>Compiling these templates will result in exactly the same
      generated files as with the previous configuration in which the default
      values were explicitly specified in the configuration. To use a value
      other than the default, the path just needs to be assigned the desired
      value. The defaults mechanism will never replace a value which was
      explicitly specified in the configuration.</para>
    </section>

    <section>
      <title>Cross-Element and Cross-Machine Validation</title>

      <para>Much of the power of using the pan language comes from its ability
      to ensure the consistency between different elements within a machine
      profile and between configurations of different machine profiles. In our
      example we have two cases where these types of validations would be
      useful: 1) the list of queues for a node should only reference defined
      queues and 2) the worker list on the server and the defined workers
      should be consistent.</para>

      <para>The file <filename>batch-types.pan</filename> will be expanded to
      include validation functions for these cases. Each validation function
      must return <literal>true</literal> if the value is valid. If the value
      is not valid, then the function can return <literal>false</literal> or
      throw an exception via the <function>error</function> function. The
      <function>error</function> function allows you to provide a descriptive
      error message for the user. The contents of the modified file
      are:</para>

      <programlisting>declaration template services/batch-types;

function valid_batch_queue_list<co xml:id="function-valid_batch_queue_list" /> = {
  foreach (index; queue_name; ARGV[0]) {
    if (!path_exists('/batch/server/queues/' + queue_name)) {
      return(false);
    };
  };
  true;
};

function valid_batch_node_dict<co xml:id="function-valid_batch_node_nlist" /> = {
  foreach (hostname; properties; ARGV[0]) {
    path = 'profiles/' + hostname + ':/batch/worker';
    if (!path_exists(path)) {
      error(path + ' doesn''t exist');
      return(false);
    };
  };
  true;
};

function server_exists<co xml:id="function-server_exists" /> = {
  return(path_exists('profiles/' + ARGV[0] + ':/batch/server'));
};

function server_knows_about_me<co xml:id="function-server_knows_about_me" /> = {
  regex = '^profiles/(.*)$';
  if (match(OBJECT, regex)) {
    parts = matches(OBJECT, regex);
    path = 'profiles/' + ARGV[0] + 
             ':/batch/server/nodes/' + parts[1];
    if (!path_exists(path)) {
      error(path + ' doesn''t exist');
    };
  } else {
    error(OBJECT + ' doesn''t match ' + regex);
  };
  true;
};

function valid_server<co xml:id="function-valid_server" /> = {
  (server_exists(ARGV[0]) &amp;&amp; server_knows_about_me(ARGV[0]));
};


type batch_capabilities = string[];

type batch_queue_list = string[1..];

type batch_node = {
  'queues' : batch_queue_list = list('default') 
               with valid_batch_queue_list(SELF)<co
          xml:id="validate-batch_queue_list" />
  'capabilities' ? batch_capabilities
};

type batch_queue = {
  'maxCpuHours' : long(0..) = 1
  'enabled' : boolean = true
};

type batch_server = {
  'nodes' : batch_node{} with valid_batch_node_dict(SELF)<co
          xml:id="validate-batch_node" />
  'queues' : batch_queue{} = dict('default', dict())
};

type batch_worker = {
  'server' : string with valid_server(SELF)<co xml:id="validate-valid_server" />
  'enabled' : boolean = true
};</programlisting>

      <calloutlist>
        <callout arearefs="function-valid_batch_queue_list">
          <para>The argument to this function is the batch queue list for a
          node. The function loops over the queue names and ensures that the
          associated path in the configuration exists. For example for the
          'default' queue, the path '/batch/server/queues/default' must
          exist.</para>
        </callout>

        <callout arearefs="function-valid_batch_node_nlist">
          <para>The argument to this function is the dict of worker nodes. The
          function loops over the worker node entries and constructs a path
          using the worker node name. For example for the worker node
          'worker01.example.org', it will construct the path
          'worker01.example.org:/batch/worker'. This is an
          <emphasis>external</emphasis> path that references another machine
          profile. In this case, the server profile 'server.example.org' will
          reference all of the worker profiles, e.g. 'worker01.example.org'.
          If the node is configured as a worker, the path '/batch/worker' will
          exist on the node.</para>
        </callout>

        <callout arearefs="function-server_exists">
          <para>The argument to this function is the name of the server as
          configured on a worker node. Similar to the previous function, this
          constructs a path on the referenced server and verifies that it
          exists. In this example, each worker will verify that the path
          'server.example.org:/batch/server' exists.</para>
        </callout>

        <callout arearefs="function-server_knows_about_me">
          <para>The argument to this function is also the name of the server
          as configured on a worker node. This function will extract the list
          of workers in the server configuration and ensure that the worker's
          name appears. This uses a regular expression to extract the machine
          name from the <varname>OBJECT</varname> variable, which contains the
          name of the object template being processed. The constructed path
          will exist if the server configuration contains the named worker
          node.</para>
        </callout>

        <callout arearefs="function-valid_server">
          <para>The argument to this function is the name of the server. It is
          a convenience function that combines the previous two
          functions.</para>
        </callout>
      </calloutlist>

      <para>These functions are tied to a type definition using a
      <literal>with</literal> clause. The <literal>with</literal> clause will
      execute the given code block for the given type after the profile has
      been fully constructed. Usually, the code block will reference the
      special variable <varname>SELF</varname>, which contains the value
      associated with the given type. Although any block of code can be used
      in the type definition, it is best practice to define a validation
      function with the code and reference that validation function. This
      makes the type definition easier to read. The <literal>with</literal>
      clauses for the cross-element and cross-machine validation are:</para>

      <calloutlist>
        <callout arearefs="validate-batch_queue_list">
          <para>Run the <function>valid_batch_queue_list</function> function
          for all of the node queue lists.</para>
        </callout>

        <callout arearefs="validate-batch_node">
          <para>Run the <function>valid_batch_node_dict</function> function
          for the server's node dict.</para>
        </callout>

        <callout arearefs="validate-valid_server">
          <para>Run the <function>valid_server</function> function for the
          worker node's configured server.</para>
        </callout>
      </calloutlist>

      <para>This type of validation ensures internal and external consistency
      of machine configurations and can significantly enhance confidence in
      the defined configurations. Note that the cross-machine validation will
      work even with circular dependencies, allowing server and client
      validation for services.</para>
    </section>

    <section>
      <title>Path Prefixes</title>

      <para>Although in this particular example there is a limited number of
      parameters set, most real examples involve a large number of parameters
      and repetitive specifications of similar absolute paths. The
      <literal>prefix</literal> pseudo-statement is a convenience for reducing
      duplication in path specifications. The path provided in the
      <literal>prefix</literal> statement will be applied to any relative
      paths found in a template <emphasis>after</emphasis> the
      <literal>prefix</literal> statement.</para>

      <para>As an example, we take the batch server configuration, adding a
      second worker node.</para>

      <programlisting>template services/batch-server;

include 'services/batch-types';

bind '/batch/server' = batch_server;

prefix '/batch/server/nodes';

'worker01.example.org/capabilities' 
    = list('sw-license', 'fast-network');

'worker02.example.org/capabilities' = list();</programlisting>

      <para>In this case, this saves us from having to duplicate the prefix
      '/batch/server/nodes' for each worker node. Note that the prefix is
      expanded when the template is compiled and <emphasis>does not</emphasis>
      affect any included templates. Although multiple
      <literal>prefix</literal> statements can be used in a template, it is
      best practice to use only one near the beginning of the template.</para>
    </section>
  </chapter>

  <chapter>
    <title>Core Syntax</title>

    <para>As you will have seen in the whirlwind tour, a complete site or
    service configuration consists of a set of files called "templates". These
    files are usually managed via a versioning system to track changes and to
    permit reverting to an earlier state. The top-level syntax of the
    templates is especially simple: a template declaration followed by a list
    of statements that are executed in sequence. The compiler will serialize a
    machine profile, usually in XML format, for each "object" template it
    encounters.</para>

    <section>
      <title>Templates</title>

      <section>
        <title>Syntax</title>

        <para>A machine configuration is defined by a set of files, called
        templates, written in the pan configuration language. These templates
        define simultaneously the configuration parameters, the configuration
        schema, and validation functions. Each template is named and is
        contained in a file having the same name.</para>

        <para>The syntax of a template file is simple:</para>

        <para><programlisting>[ <replaceable>modifier</replaceable> ] <literal>template</literal> <replaceable>template-name</replaceable>;
[ statement ... ]</programlisting></para>

        <para>where the optional modifier is either <literal>object</literal>,
        <literal>structure</literal>, <literal>unique</literal>, or
        <literal>declaration</literal>. There are five different types of
        templates that are identified by the template modifier; the four
        listed above and an "ordinary" template that has no modifier.</para>

        <para>A template name is a series of substrings separated by slashes.
        Each substring may consist of letters, digits, underscores, hyphens,
        periods, and pluses. The substrings may not be empty or begin with a
        period; the template name may not begin or end with a slash.</para>

        <para>Each template must reside in a separate file with the name
        <filename><replaceable>template-name</replaceable>.pan</filename> with
        any terms separated with slashes corresponding to subdirectories. For
        example, a template with the name "service/batch/worker-23" must have
        a file name of <filename>worker-23.pan</filename> and reside in a
        subdirectory <filename>service/batch/</filename>.</para>

        <note>
          <para>The older file extension "tpl" is also accepted by the pan
          compiler, but the "pan" extension is preferred. If files with both
          extensions exist for a given template, then the file with the "pan"
          extension will be used by the compiler.</para>
        </note>
      </section>

      <section>
        <title>Types of Templates</title>

        <section>
          <title>Object Templates</title>

          <para>An object template is declared via the
          <literal>object</literal> modifier. Each object template is
          associated with a machine profile and the pan compiler will, by
          default, generate an XML profile for each processed object template.
          An object template may contain any of the pan statements. Statements
          that operate on paths may contain only absolute paths.</para>

          <para>Object template names may be namespaced, allowing organization
          of object templates in directory structures as is done for other
          templates. For the automatic loading mechanism to find object
          templates, the root directory containing them must be specified
          explicitly in the load path (either on the command line or via the
          <varname>LOADPATH</varname> variable).</para>
        </section>

        <section>
          <title>Ordinary Templates</title>

          <para>An ordinary template uses no template modifier in the
          declaration. These templates may contain any pan statement, but
          statements must operate only on absolute paths.</para>
        </section>

        <section>
          <title>Unique Templates</title>

          <para>A template defined with the <literal>unique</literal> modifier
          behaves like an ordinary template except that it will only be
          included once for each processed object template. It has the same
          restrictions as an ordinary template. It will be executed when the
          first include statement referencing the template is
          encountered.</para>
        </section>

        <section>
          <title>Declaration Templates</title>

          <para>A template declared with a <literal>declaration</literal>
          modifier is a declaration template. These templates may contain only
          those pan statements that do not modify the machine profile. That
          is, they may contain only <command>type</command>,
          <command>bind</command>, <command>variable</command>, and
          <command>function</command> statements. A declaration template will
          only be executed once for each processed object template no matter
          how many times it is included. It will be executed when the first
          include statement referencing the template is encountered.</para>
        </section>

        <section>
          <title>Structure Templates</title>

          <para>A template declared with the <literal>structure</literal>
          modifier may only contain <command>include</command> statements and
          assignment statements that operate on relative paths. The
          <command>include</command> statements may only reference other
          structure templates. Structure templates are an alternative for
          creating dicts and are used via the <function>create</function>
          function.</para>
        </section>
      </section>
    </section>

    <section>
      <title>Comments</title>

      <para>These files may contain comments that start with the hash sign
      ('#') and terminate with the next new line or end of file. Comments may
      occur anywhere in the file except in the middle of strings, where they
      will be taken to be part of the string itself.</para>

      <para>Whitespace in the template files is ignored except when it is used
      to separate language tokens.</para>
    </section>

    <section>
      <title>Statements</title>

      <section>
        <title>Assignment</title>

        <para>Assignment statements are used to modify a part of the
        configuration tree by replacing the subtree identified by its path by
        the result of the execution a DML block. This result can be a single
        property or a resource holding any number of elements. The
        unconditional assignment is:</para>

        <para><programlisting>[ final ] path = dml; </programlisting></para>

        <para>where the path is represented by a string literal. Single-quoted
        strings are slightly more efficient, but double-quoted strings work as
        well.</para>

        <para>The assignment will create parents of the value that do not
        already exist.</para>

        <para>If a value already exists, the pan compiler will verify that the
        new value has a compatible type. If not, it will terminate the
        processing with an error.</para>

        <para>If the <literal>final</literal> modifier is used, then the path
        and any children of that path may not be subsequently modified.
        Attempts to do so will result in a fatal error.</para>

        <para>A conditional form of the assignment statement also
        exists:</para>

        <para><programlisting>[ final ] path ?= dml;</programlisting></para>

        <para>where the path is again represented by a string literal. The
        conditional form (?=) will only execute the DML block and assign a
        value if the named path does not exist or contains the
        <literal>undef</literal> value.</para>
      </section>

      <section>
        <title>Prefix</title>

        <para>The <command>prefix</command> (pseudo-)statement provides an
        absolute path used to resolve relative paths in assignment statements
        that occur afterwards in the template. It has the form:</para>

        <para><programlisting>prefix '/some/absolute/path';</programlisting></para>

        <para>The path must be an absolute path or an empty string. If the
        empty string is given, no prefix is used for subsequent assignment
        statements with relative paths. The <command>prefix</command>
        statement can be used multiple times within a given template.</para>

        <para><emphasis>This statement is evaluated at compile time and only
        affects assignment statements in the same file as the
        definition.</emphasis></para>
      </section>

      <section>
        <title>Include</title>

        <para>The <command>include</command> statement acts as if the contents
        of the named template were included literally at the point the
        <command>include</command> statement is executed.</para>

        <para><programlisting>include dml;</programlisting></para>

        <para>The DML block must evaluate to a string,
        <literal>undef</literal>, or <literal>null</literal>. If the result is
        <literal>undef</literal> or <literal>null</literal>, the
        <command>include</command> statement does nothing; if the result is a
        string, the named template is loaded and executed. Any other type will
        generate an error.</para>

        <para>Ordinary templates may be included multiple times. Templates
        marked as <literal>declaration</literal> or <literal>unique</literal>
        templates will be only included once where first encountered. Includes
        which create cyclic dependencies are not permitted and will generate a
        fatal error.</para>

        <para>There are some restrictions on what types of templates can be
        included. Object templates cannot be included. Structure templates can
        only include and be included by other structure templates. Declaration
        templates can only include other declaration templates. All other
        combinations are allowed.</para>
      </section>

      <section>
        <title>Variable Definition</title>

        <para>Global variables can be defined via a
        <command>variable</command> statement. These may be referenced from
        any DML block after being defined. They may not be modified from a DML
        block; they can only be modified from a <command>variable</command>
        statement. Like the assignment statement there are conditional and
        unconditional forms:</para>

        <programlisting>[ final ] variable identifier ?= dml;
[ final ] variable identifier = dml;</programlisting>

        <para>For the conditional form, the DML block will only be evaluated
        and the assignment done if the variable does not exist or has the
        <literal>undef</literal> value.</para>

        <para>If the <literal>final</literal> modifier is used, then the
        variable may not be subsequently modified. Attempts to do so will
        result in a fatal error.</para>

        <para>Pan provides several automatic global variables:
        <varname>OBJECT</varname>, <varname>SELF</varname>,
        <varname>FUNCTION</varname>, <varname>TEMPLATE</varname>, and
        <varname>LOADPATH</varname>. <varname>OBJECT</varname> contains the
        name of the object template being evaluated; it is a final variable.
        <varname>SELF</varname> is the current value of a path referred to in
        an assignment or variable statement. The <varname>SELF</varname>
        reference cannot be modified, but children of <varname>SELF</varname>
        may be. <varname>FUNCTION</varname> contains the name of the current
        function, if it exists. <varname>FUNCTION</varname> is a final
        variable. <varname>TEMPLATE</varname> contains the name of the
        template that invoked the current DML block; it is a final variable.
        <varname>LOADPATH</varname> can be used to modify the load path used
        to locate template for the <command>include</command>
        statement.</para>

        <para>Any valid identifier may be used to name a global
        variable.</para>

        <caution>
          <para>Global and local variables share a common namespace. Best
          practice dictates that global variables have names with all
          uppercase letters (e.g. <varname>MY_GLOBAL_VAR</varname>) and local
          variables have names with all lowercase letters (e.g.
          <varname>my_local_var</varname>). This avoids conflicts and
          unexpected errors when sharing configurations.</para>
        </caution>
      </section>

      <section>
        <title>Function Definition</title>

        <para>Functions can be defined by the user. These are arbitrary DML
        blocks bound to an identifier. Once defined, functions can be called
        from any subsequent DML block. Functions may only be defined once;
        attempts to redefine an existing function will cause the compilation
        to abort. The function definition syntax is:</para>

        <para><programlisting>function identifier = dml; </programlisting></para>

        <para>See the Function section for more information on user-defined
        functions and a list of built-in functions.</para>

        <para>Note that the compiler keeps distinct function and type
        namespaces. One can define a function and type with the same
        names.</para>
      </section>

      <section>
        <title>Type Definition</title>

        <para>Type definitions are critical for the validation of the
        generated machine profiles. Types can be built up from the primitive
        pan types and arbitrary validation functions. New types can be defined
        with</para>

        <para><programlisting>type identifier = type-spec;</programlisting></para>

        <para>A type may be defined only once; attempts to redefine an
        existing type will cause the compilation to abort. Types referenced in
        the type-spec must already be defined. See the Type section for more
        details on the syntax of the type specification.</para>

        <para>Note that the compiler keeps distinct function and type
        namespaces. One can define a function and type with the same
        name.</para>
      </section>

      <section>
        <title>Validation</title>

        <para>The <command>bind</command> statement binds a type definition to
        a path. Multiple types may be bound to a single path. During the
        validation phase, the value corresponding to the named path will be
        checked against the bound types.</para>

        <programlisting>bind path = type-spec;</programlisting>

        <para>See the Type section for a complete description of the
        <replaceable>type-spec</replaceable> syntax.</para>

        <para>The <command>valid</command> statement binds a validation DML
        block to a path. It has the form:</para>

        <para><programlisting>valid path = DML;</programlisting></para>

        <para>This is a convenience statement and has exactly the same effect
        as the statement:</para>

        <para><programlisting>bind path = element with DML;</programlisting></para>

        <para>The pan compiler internally implements this statement as the
        <command>bind</command> statement above.</para>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Data Types</title>

    <para>The data typing system forms the foundation of the validation
    features of the pan language. All configuration elements are implicitly
    typed based on values assigned to them. Types, once inferred, are enforced
    by the compiler.</para>

    <section>
      <title>Type Hierarchy</title>

      <para>There are four primitive, atomic types in the pan language:
      boolean, long, double, and string. Additionally, there are three
      string-like types: path, link, and regular expression. These appear in
      special constructs and have additional validity constraints associated
      with them. All of these atomic types are known as "properties".</para>

      <para>The language contains two types of collections: list and dict. The
      'list' is an ordered list of elements, which uses the index (an integer)
      as the key. The named list (dict) associates a string key with a value;
      these are also known as hashes or associative lists. These collections
      are known as "resources".</para>

      <para>The complete type hierarchy is shown in <xref
      linkend="fig-types" />, including the two special types
      <literal>undef</literal> and <literal>null</literal>.</para>

      <figure xml:id="fig-types">
        <title>Pan language type hierarchy</title>

        <mediaobject>
          <alt>Pan language type hierarchy</alt>

          <imageobject role="html">
            <imagedata align="center" contentwidth="14cm"
                       fileref="images/pan-type-hierarchy-truncated.png"
                       format="PNG"></imagedata>
          </imageobject>

          <imageobject role="fo">
            <imagedata align="center" contentwidth="14cm"
                       fileref="images/pan-type-hierarchy-truncated.svg"
                       format="SVG" valign="middle"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <section>
        <title>Implicit Typing</title>

        <para>If you worked through the exercises of the previous section, you
        will have discovered that although you have an intuitive idea of what
        type a particular path should contain (e.g.
        <literal>/hardware/cpu/number</literal> should be positive long), the
        pan compiler does not. Downstream tools to configure a machine will
        likely expect certain values to have certain types and will produce
        errors or erroneous configurations if the correct type is not used.
        One of the strengths of the pan language is to specify constraints on
        the values to detect problems before configurations are deployed to
        machines.</para>

        <para>All of the elements in a configuration will have a concrete data
        type assigned to them. Usually this is inferred from the configuration
        itself. Once a concrete data type has been assigned to an element, the
        compiler will enforce the data type, disallowing replacement of a long
        value with a string, for instance. More detailed validation must be
        explicitly defined in the configuration (see the Validation
        chapter).</para>
      </section>
    </section>

    <section>
      <title>Properties and Primitive Types</title>

      <section>
        <title>Boolean Literals</title>

        <para>There are exactly two possible boolean values:
        <literal>true</literal> and <literal>false</literal>. They must appear
        as an unquoted word and completely in lowercase.</para>
      </section>

      <section>
        <title>Long Literals</title>

        <para>Long literals may be given in decimal, hexadecimal, or octal
        format. A decimal literal is a sequence of digits starting with a
        number other than zero. A hexadecimal literal starts with the '0x' or
        '0X' and is followed by a sequence of hexadecimal digits. An octal
        literal starts with a zero is followed by a sequence of octal digits.
        Examples:</para>

        <programlisting>123  # decimal long literal
0755 # octal long literal
0xFF # hexadecimal long literal</programlisting>

        <para>Long literals are represented internally as an 8-byte signed
        number. Long values that cannot be represented in 8 bytes will cause a
        syntax error to be thrown.</para>
      </section>

      <section>
        <title>Double Literals</title>

        <para>Double literals represent a floating point number. A double
        literal must start with a digit and must contain either a decimal
        point or an exponent. Examples:</para>

        <programlisting>0.01
3.14159
1e-8
1.3E10</programlisting>

        <para>Note that '.2' is not a valid double literal; this value must be
        written as '0.2'.</para>

        <para>Double literals are represented internally as an 8-byte value.
        Double values that cannot be represented in 8 bytes will cause a
        syntax error to be thrown.</para>
      </section>

      <section>
        <title>String Literals</title>

        <para>The string literals can be expressed in three different forms.
        They can be of any length and can contain any character, including the
        NULL byte.</para>

        <para>Single quoted strings are used to represent short and simple
        strings. They cannot span several lines and all the characters will
        appear verbatim in the string, except the doubled single quote which
        is used to represent a single quote inside the string. For
        instance:</para>

        <programlisting>’foo’ 
’it’’s a sentence’ 
’ˆ\d+\.\d+$’ </programlisting>

        <para>This is the most efficient string representation and should be
        used when possible.</para>

        <para>Double quoted strings are more flexible and use the backslash to
        represent escape sequences. For instance:</para>

        <programlisting>"foo" 
"it’s a sentence" 
"Java-style escapes: \t (tab) \r (carriage return) \n (newline)" 
"Java-style escapes: \b (backspace) \f (form feed)" 
"Hexadecimal escapes: \x3d (=) \x00 (NULL byte) \x0A (newline)" 
"Miscellaneous escapes: \" (double quote) \\ (backslash)" 
"this string spans two lines and\
does not contain a newline"</programlisting>

        <para>Invalid escape sequences will cause a syntax error to be
        thrown.</para>

        <para>Multi-line strings can be represented using the 'here-doc'
        syntax, like in shell or Perl.</para>

        <programlisting>'/test' = 'foo' + &lt;&lt;EOT + 'bar'; 
this code will assign to the path '/test' the string 
made of ‘foo’, plus this text including the final newline, 
plus ‘bar’... 
EOT</programlisting>

        <para>The contents of the 'here-doc' are treated as a single-quoted
        string. That is, no escape processing is done.</para>

        <para>The easiest solution to put binary data inside pan code is to
        base64 encode it and put it inside "here-doc” strings like in the
        following example:</para>

        <programlisting>'/system/binary/stuff' = base64_decode(&lt;&lt;EOT); 
H4sIAOwLyDwAA02PQQ7DMAgE731FX9BT1f8Q
Z52iYhthEiW/r2SitCdmxCK0E3W8no+36n2G 
8UbOrYYWGROCgurBe4JeCexI2ahgWF5rulaL
tImkDxbucS0tcc3t5GXMAqeZnIYo+TvAmsL8 
GGLobbUUX7pT+pxkXJc/5Bx5p0ki7Cgq5Kcc
GrCR8PzruUfP2xfJgVqHCgEAAA== 
EOT</programlisting>

        <para>The <function>base64_decode</function> function is one of the
        built-in pan functions.</para>
      </section>
    </section>

    <section>
      <title>String-Like Types</title>

      <section>
        <title>Path</title>

        <para>Pan paths are represented as string literals; either of the
        standard quoted forms for a string literal can be used to represent a
        path. There are three different types of paths: external, absolute,
        and relative.</para>

        <para>An <emphasis>external path</emphasis> explicitly references an
        object template. The syntax for an external path is:</para>

        <programlisting>my/external/object:/some/absolute/path</programlisting>

        <para>where the substring before the colon is the template name and
        the substring after the colon is an absolute path. The leading slash
        of the absolute path is optional in an external path. This form will
        work for both namespaced and non-namespaced object templates.</para>

        <para>An <emphasis>absolute path</emphasis> starts at the top of a
        configuration tree and identifies a node within the tree. All absolute
        paths start with a slash ("/") and are followed by a series of terms
        that identify a specific child of each resource. A bare slash ("/")
        refers to the full configuration tree. The allowed syntax for each
        term in the path is described below.</para>

        <para>A <emphasis>relative path</emphasis> refers to a path relative
        to a structure template. Relative paths do not start with a slash, but
        otherwise are identical to the absolute paths.</para>

        <para>Terms may consist of letters, digits, underscores, hyphens, and
        pluses. Terms beginning with a digit must be a valid long literal.
        Terms that contain other characters must be escaped, either by using
        the <function>escape</function> function within a DML block or by
        enclosing the term within braces for a path literal. For example, the
        following creates an absolute path with three terms:</para>

        <programlisting>/alpha/{a/b}/gamma</programlisting>

        <para>The second term is equivalent to
        <function>escape</function>('a/b').</para>
      </section>

      <section>
        <title>Link</title>

        <para>A property can hold a reference to another element; this is
        known as a link. The value of the link is the absolute path of the
        referenced element. A property explicitly declared to be a link will
        be validated to ensure that 1) it represents a valid absolute path and
        2) that the given path exists in the final configuration.</para>
      </section>

      <section>
        <title>Regular Expression</title>

        <para>Regular expressions are written as a standard pan string
        literals. The implementation exposes the Java regular expression
        syntax, which is largely compatible with the Perl regular expression
        syntax. Because certain characters have a special meaning in pan
        double quoted strings, characters like backslashes will need to be
        escaped; consequently, it is preferable to use single-quoted strings
        for regular expression literals.</para>

        <para>When the compiler can infer that a string literal must be a
        regular expression, it will validate the regular expression at compile
        time, failing when an invalid regular expression is provided.</para>
      </section>
    </section>

    <section>
      <title>Resources</title>

      <para>There are two types of <emphasis>resources</emphasis> supported by
      pan: list and dict. A list is an ordered list of elements with the
      indexing starting at zero. In the above example, there are two lists
      <literal>/hardware/disks/ide</literal> and
      <literal>/hardware/nic</literal>. The order of a list is significant and
      maintained in the serialized representation of the configuration. An
      dict (named list) associates a name with an element; these are also
      known as hashes or associative arrays. One dict in the above example is
      <literal>/hardware/cpu</literal>, which has <literal>arch</literal>,
      <literal>cores</literal>, <literal>model</literal>,
      <literal>number</literal>, and <literal>speed</literal> as children.
      Note that the order of an dict is <emphasis>not</emphasis> significant
      and that the order specified in the template file is
      <emphasis>not</emphasis> preserved in the serialized version of the
      configuration. Although the algorithm for ordering the children of an
      dict in the serialized file is not specified, the pan compiler
      guarantees a <emphasis>consistent</emphasis> ordering of the same
      children from one compilation to the next.</para>

      <para>Within a given path, lists and dicts can be distinguished by the
      names of their children. Lists always have children whose names are
      valid long literals. In the following example,
      <filename>/mylist</filename> is a list with three children:</para>

      <programlisting>object template mylist;

'/mylist/0' = 'decimal index';
'/mylist/01' = 'octal index';
'/mylist/0x2' = 'hexadecimal index';</programlisting>

      <para>The indices can be specified in decimal, octal, or hexadecimal.
      The names of children in an dict must begin with a letter or
      underscore.</para>
    </section>

    <section>
      <title>Special Types</title>

      <para>The pan language contains two special types:
      <literal>undef</literal> and <literal>null</literal>.</para>

      <para>The <literal>undef</literal> literal can be used to represent the
      undefined element, i.e. an element which is neither a property nor a
      resource. The undefined element cannot be written to a final machine
      profile and most built-in functions will report a fatal error when
      processing it. It can be used to mark an element that must be
      overwritten during the processing.</para>

      <para>The <literal>null</literal> value deletes the path or global
      variable to which it is assigned. Most operations and functions will
      report an error if this value is processed directly.</para>
    </section>
  </chapter>

  <chapter>
    <title>Data Manipulation Language (DML)</title>

    <para>Any non-trivial configuration will need to have some values that are
    calculated. The Data Manipulation Language (DML), a subset of the full pan
    configuration language, fulfills this role. This subset has the features
    of many imperative programming languages, but can
    <emphasis>only</emphasis> be used on the right-hand side of a statement,
    that is, to calculate a value.</para>

    <section>
      <title>DML Syntax</title>

      <para>A DML block consists of one or more statements separated by
      semicolons. The block must be delimited by braces if there is more than
      one statement. The value of the block is the value of the last statement
      executed within the block. <emphasis>All</emphasis> DML statements
      return a value, even flow control statements like <literal>if</literal>
      and <literal>foreach</literal>.</para>
    </section>

    <section>
      <title>Variables</title>

      <para>To ease data handling, you can use local variables in any DML
      expression. They are scoped to the <emphasis>outermost</emphasis>
      enclosing DML expression. They do not need to be declared before they
      are used. The local variables are destroyed once the outermost enclosing
      DML block terminates.</para>

      <para>As a first approximation, variables work the way you expect them
      to work. They can contain properties and resources and you can easily
      access resource children using square brackets:</para>

      <programlisting># populate /table which is an dict 
’/table/red’ = ’rouge’; 
’/table/green’ = ’vert’; 

’/test’ = { 
  x = list(’a’, ’b’, ’c’); # x is a list 
  y = value(’/table’);     # y is a dict 
  z = x[1] + y[’red’];     # z is a string ('arouge')
  length(z);               # this will be 6 
};</programlisting>

      <para>Local variables are subject to primitive type checking. So the
      primitive type of a local variable cannot be changed unless the variable
      is assigned to <literal>undef</literal> or <literal>null</literal>
      between the type-changing assignments.</para>

      <para>Global variables (defined with the <command>variable</command>
      statement) can be read from the DML block. Global variables may not be
      modified from within the block; attempting to do so will abort the
      execution.</para>

      <caution>
        <para>Global and local variables share the same namespace.
        Consequently, there may be unintended naming conflicts between them.
        The best practice to avoid this is to name all local variables with
        all lowercase letters (e.g. <varname>my_local_var</varname>) and all
        global variables with all uppercase letters (e.g.
        <varname>MY_GLOBAL_VAR</varname>).</para>
      </caution>
    </section>

    <section>
      <title>Operators</title>

      <para>The operators available in the pan Data Manipulation Language
      (DML) are very similar to those in the Java or c languages. The
      following tables summarize the DML operators. The valid primitive types
      for each operator are indicated. Those marked with "number" will take
      either long or double arguments. In the case of binary operators, the
      result will be promoted to a double if the operands are mixed.</para>

      <table>
        <title>Unary DML Operators</title>

        <?dbfo table-width="75%"?>

        <?dbfo table-layout="fixed"?>

        <tgroup cols="3">
          <colspec align="center" colnum="1" colwidth="1*" />

          <colspec align="left" colnum="2" colwidth="2*" />

          <colspec align="left" colnum="3" colwidth="5*" />

          <tbody>
            <row>
              <entry>+</entry>

              <entry>number</entry>

              <entry>preserves sign of argument</entry>
            </row>

            <row>
              <entry>-</entry>

              <entry>number</entry>

              <entry>changes sign of argument</entry>
            </row>

            <row>
              <entry>~</entry>

              <entry>long</entry>

              <entry>bitwise not</entry>
            </row>

            <row>
              <entry>!</entry>

              <entry>boolean</entry>

              <entry>logical not</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Binary DML Operators</title>

        <?dbfo table-width="75%"?>

        <?dbfo table-layout="fixed"?>

        <tgroup cols="3">
          <colspec align="center" colnum="1" colwidth="1*" />

          <colspec align="left" colnum="2" colwidth="2*" />

          <colspec align="left" colnum="3" colwidth="5*" />

          <tbody>
            <row>
              <entry>+</entry>

              <entry>number</entry>

              <entry>addition</entry>
            </row>

            <row>
              <entry>+</entry>

              <entry>string</entry>

              <entry>string concatenation</entry>
            </row>

            <row>
              <entry>-</entry>

              <entry>number</entry>

              <entry>subtraction</entry>
            </row>

            <row>
              <entry>*</entry>

              <entry>number</entry>

              <entry>multiplication</entry>
            </row>

            <row>
              <entry>/</entry>

              <entry>number</entry>

              <entry>division</entry>
            </row>

            <row>
              <entry>%</entry>

              <entry>long</entry>

              <entry>modulus</entry>
            </row>

            <row>
              <entry>&amp;</entry>

              <entry>long</entry>

              <entry>bitwise and</entry>
            </row>

            <row>
              <entry>|</entry>

              <entry>long</entry>

              <entry>bitwise or</entry>
            </row>

            <row>
              <entry>^</entry>

              <entry>long</entry>

              <entry>bitwise exclusive or</entry>
            </row>

            <row>
              <entry>&amp;&amp;</entry>

              <entry>boolean</entry>

              <entry>logical and (short-circuit logic)</entry>
            </row>

            <row>
              <entry>||</entry>

              <entry>boolean</entry>

              <entry>logical or (short-circuit logic)</entry>
            </row>

            <row>
              <entry>==</entry>

              <entry>number</entry>

              <entry>equal</entry>
            </row>

            <row>
              <entry>==</entry>

              <entry>string</entry>

              <entry>lexical equal</entry>
            </row>

            <row>
              <entry>!=</entry>

              <entry>number</entry>

              <entry>not equal</entry>
            </row>

            <row>
              <entry>!=</entry>

              <entry>string</entry>

              <entry>lexical not equal</entry>
            </row>

            <row>
              <entry>&gt;</entry>

              <entry>number</entry>

              <entry>greater than</entry>
            </row>

            <row>
              <entry>&gt;</entry>

              <entry>string</entry>

              <entry>lexical greater than</entry>
            </row>

            <row>
              <entry>&gt;=</entry>

              <entry>number</entry>

              <entry>greater than or equal</entry>
            </row>

            <row>
              <entry>&gt;=</entry>

              <entry>string</entry>

              <entry>lexical greater than or equal</entry>
            </row>

            <row>
              <entry>&lt;</entry>

              <entry>number</entry>

              <entry>less than</entry>
            </row>

            <row>
              <entry>&lt;</entry>

              <entry>string</entry>

              <entry>lexical less than</entry>
            </row>

            <row>
              <entry>&lt;=</entry>

              <entry>number</entry>

              <entry>less than or equal</entry>
            </row>

            <row>
              <entry>&lt;=</entry>

              <entry>string</entry>

              <entry>lexical less than or equal</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Operator Precedence (lowest to highest)</title>

        <?dbfo table-width="50%"?>

        <tgroup align="center" cols="1">
          <tbody>
            <row>
              <entry>||</entry>
            </row>

            <row>
              <entry>&amp;&amp;</entry>
            </row>

            <row>
              <entry>|</entry>
            </row>

            <row>
              <entry>^</entry>
            </row>

            <row>
              <entry>&amp;</entry>
            </row>

            <row>
              <entry>==, !=</entry>
            </row>

            <row>
              <entry>&lt;, &lt;=, &gt;, &gt;=</entry>
            </row>

            <row>
              <entry>+ (binary), - (binary)</entry>
            </row>

            <row>
              <entry>*, /, %</entry>
            </row>

            <row>
              <entry>+ (unary), - (unary), !, ~</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Flow Control</title>

      <para>DML contains four statements that permit non-linear execution of
      code within a DML block. The <literal>if</literal> statement allows
      conditional branches, the <literal>while</literal> statement allows
      looping over a DML block, the <literal>for</literal> statement allows
      the same, and the <literal>foreach</literal> statement allows iteration
      over an entire resource (<type>list</type> or <type>dict</type>).</para>

      <caution>
        <para>These statements, like all DML statements, return a value. Be
        careful of this, because unexecuted blocks generally will return
        <literal>undef</literal>, which may lead to unexpected
        behavior.</para>
      </caution>

      <section>
        <title>Branching (<literal>if</literal> statement)</title>

        <para>The <literal>if</literal> statement allows the conditional
        execution of a DML block. The statement may include an
        <literal>else</literal> clause that will be executed if the condition
        is <literal>false</literal>. The syntax is:</para>

        <programlisting>if ( condition-dml ) true-dml;
if ( condition-dml ) true-dml else false-dml;</programlisting>

        <para>where all of the blocks may either be a single DML statement or
        a multi-statement DML block.</para>

        <para>The value returned by this statement is the value returned by
        the <replaceable>true-dml</replaceable> or
        <replaceable>false-dml</replaceable> block, whichever is actually
        executed. If the <literal>else</literal> clause is not present and the
        <replaceable>condition-dml</replaceable> is false, the if statement
        returns <literal>undef</literal>.</para>
      </section>

      <section>
        <title>Looping (<literal>while</literal> and <literal>for</literal>
        statements)</title>

        <para>Simple looping behavior is provided by the
        <literal>while</literal> statement. The syntax is:</para>

        <programlisting>while ( condition-dml ) body-dml;</programlisting>

        <para>The loop will continue until the
        <replaceable>condition-dml</replaceable> evaluates as
        <literal>false</literal>. The value of this statement is that returned
        by the <replaceable>body-dml</replaceable> block. If the
        <replaceable>body-dml</replaceable> block is never executed, then
        <literal>undef</literal> is returned.</para>

        <para>The pan language also contains a <literal>for</literal>
        statement that in many cases provides a more concise syntax for many
        types of loops. The syntax is:</para>

        <programlisting>for (initialization-dml; condition-dml; increment-dml) body-dml;</programlisting>

        <para>The <replaceable>initialization-dml</replaceable> block will
        first be executed. Before each iteration the
        <replaceable>condition-dml</replaceable> block will be executed; the
        <replaceable>body-dml</replaceable> will only be executed (again) if
        the condition evaluates to <literal>true</literal>. After each
        iteration, the <replaceable>increment-dml</replaceable> block is
        executed. If the condition never evaluates to <literal>true</literal>,
        then the value of the statement will be that of the
        <replaceable>initialization-dml</replaceable>. All of the DML blocks
        must be present, but those not of interest can be defined as just
        <literal>undef</literal>.</para>

        <para>Note that the compiler enforces an iteration limit to avoid
        infinite loops. Loops exceeding the iteration limit will cause the
        compiler to abort the execution. The value of this limit can be set
        via a compiler option.</para>
      </section>

      <section>
        <title>Iteration (<literal>foreach</literal> statement)</title>

        <para>The <command>foreach</command> statement allows iteration over
        all of the elements of a list or dict. The syntax is:</para>

        <programlisting>foreach (key; value; resource) body-dml;</programlisting>

        <para>This will cause the <replaceable>body-dml</replaceable> to be
        executed once for each element in resource (a list or dict). The local
        variables <varname>key</varname> and <varname>value</varname> (you can
        choose these names) will be set at each iteration to the key and value
        of the element. For a list, the <varname>key</varname> is the
        element's index. The iteration will always occur in the natural order
        of the resource: ordinal order for lists and lexical order of the keys
        for dicts.</para>

        <para>The value returned will be that of the last iteration of the
        <replaceable>body-dml</replaceable>. If the
        <replaceable>body-dml</replaceable> is never executed (for an empty
        list or dict), <literal>undef</literal> will be returned.</para>

        <para>The <command>foreach</command> statement is not subject to the
        compiler's iteration limit. By definition, the resource has a finite
        number of entries, so this safeguard is not needed.</para>

        <para>This form of iteration should be used in preference to the
        <function>first</function>, <function>next</function>, and
        <function>key</function> functions whenever possible. It is more
        efficient than the functional forms and less prone to error.</para>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Functions</title>

    <para>The pan configuration has a rich set of built-in functions for
    manipulating elements and for debugging. In addition, user-defined
    functions can be specified, which are often used to make configurations
    more modular and maintainable.</para>

    <section>
      <title>Built-In Functions</title>

      <para>Built-in functions are actually treated as operators within the
      DML language. Because of this, they are highly optimized and often
      process their arguments specially. In all cases, users should prefer
      built-in functions to user-defined functions when possible. The
      following tables describe all of the built-in functions; refer to the
      appendix to see the arguments and other detailed information about the
      functions.</para>

      <table>
        <title>String Manipulation Functions</title>

        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="1*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <tbody>
            <row>
              <entry><xref linkend="file_contents" /></entry>

              <entry>Lookup the named file and provide the file's contents as
              a string.</entry>
            </row>

            <row>
              <entry><xref linkend="format" /></entry>

              <entry>Generate a formatted string based on the formatting
              parameters and the values provided.</entry>
            </row>

            <row>
              <entry><xref linkend="index" /></entry>

              <entry>Return the index of a substring or -1 if the substring is
              not found.</entry>
            </row>

            <row>
              <entry><xref linkend="length" /></entry>

              <entry>Gives the length of a string.</entry>
            </row>

            <row>
              <entry><xref linkend="match" /></entry>

              <entry>Return a boolean indicating if a string matches the given
              regular expression.</entry>
            </row>

            <row>
              <entry><xref linkend="matches" /></entry>

              <entry>Return an array containing the matched string and matched
              groups for a given string and regular expression.</entry>
            </row>

            <row>
              <entry><xref linkend="replace" /></entry>

              <entry>Replace all occurrences of a substring within a given
              string.</entry>
            </row>

            <row>
              <entry><xref linkend="splice" /></entry>

              <entry>Remove a substring and optionally replace it with
              another.</entry>
            </row>

            <row>
              <entry><xref linkend="split" /></entry>

              <entry>Split a string based on a given regular expression and
              return an array of the results.</entry>
            </row>

            <row>
              <entry><xref linkend="substr" /></entry>

              <entry>Extract a substring from the given string.</entry>
            </row>

            <row>
              <entry><xref linkend="to_lowercase" /></entry>

              <entry>Change all of the characters in a string to lowercase
              (using the US locale).</entry>
            </row>

            <row>
              <entry><xref linkend="to_uppercase" /></entry>

              <entry>Change all of the characters in a string to uppercase
              (using the US locale).</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Debugging Functions</title>

        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="1*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <tbody>
            <row>
              <entry><xref linkend="debug" /></entry>

              <entry>Print a debugging message to the standard error stream.
              Returns the message or <literal>undef</literal>.</entry>
            </row>

            <row>
              <entry><xref linkend="error" /></entry>

              <entry>Print an error message to the standard error and
              terminate processing.</entry>
            </row>

            <row>
              <entry><xref linkend="traceback" /></entry>

              <entry>Print an error message to the standard error along with a
              traceback. Returns <literal>undef</literal>.</entry>
            </row>

            <row>
              <entry><xref linkend="deprecated" /></entry>

              <entry>Print a warning message to the standard error if required
              by the deprecation level in effect. Returns <literal>the message
              or undef</literal>.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Encoding and Decoding Functions</title>

        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="1*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <tbody>
            <row>
              <entry><xref linkend="base64_decode" /></entry>

              <entry>Decode a string that is encoded using the Base64
              standard.</entry>
            </row>

            <row>
              <entry><xref linkend="base64_encode" /></entry>

              <entry>Encode a string using the Base64 standard.</entry>
            </row>

            <row>
              <entry><xref linkend="digest" /></entry>

              <entry>Create message digest using specified algorithm.</entry>
            </row>

            <row>
              <entry><xref linkend="escape" /></entry>

              <entry>Escape characters within the string to ensure string is a
              valid dict key (path term).</entry>
            </row>

            <row>
              <entry><xref linkend="unescape" /></entry>

              <entry>Transform an escaped string into its original
              form.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Resource Manipulation Functions</title>

        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="1*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <tbody>
            <row>
              <entry><xref linkend="append" /></entry>

              <entry>Add a value to the end of a list.</entry>
            </row>

            <row>
              <entry><xref linkend="create" /></entry>

              <entry>Create an dict from the named structure template.</entry>
            </row>

            <row>
              <entry><xref linkend="first" /></entry>

              <entry>Initialize an iterator over a resource. Returns a boolean
              to indicate if more values exist in the resource.</entry>
            </row>

            <row>
              <entry><xref linkend="nlist" /></entry>

              <entry>Create an dict from the given key/value pairs given as
              arguments.</entry>
            </row>

            <row>
              <entry><xref linkend="key" /></entry>

              <entry>Find the n'th key in an dict.</entry>
            </row>

            <row>
              <entry><xref linkend="length" /></entry>

              <entry>Get the number of elements in the given resource.</entry>
            </row>

            <row>
              <entry><xref linkend="list" /></entry>

              <entry>Create a list from the given arguments.</entry>
            </row>

            <row>
              <entry><xref linkend="merge" /></entry>

              <entry>Perge two resources into a single one. This function
              always creates a new resource and leaves the arguments
              untouched.</entry>
            </row>

            <row>
              <entry><xref linkend="next" /></entry>

              <entry>Extract the next value while iterating over a resource.
              Returns a boolean to indicate if more values exist in the
              resource.</entry>
            </row>

            <row>
              <entry><xref linkend="prepend" /></entry>

              <entry>Add a value to the beginning of a list.</entry>
            </row>

            <row>
              <entry><xref linkend="splice" /></entry>

              <entry>Remove a section of a list and optionally replace removed
              values with those in a given list.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Type Checking Functions</title>

        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="1*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <tbody>
            <row>
              <entry><xref linkend="is_boolean" /></entry>

              <entry>Check if the argument is a boolean value. If the argument
              is a simple variable reference and the referenced variable does
              not exist, the function will return false rather than raising an
              error.</entry>
            </row>

            <row>
              <entry><xref linkend="is_defined" /></entry>

              <entry>Check if the argument is a value other than
              <literal>null</literal> or <literal>undef</literal>. If the
              argument is a simple variable reference and the referenced
              variable does not exist, the function will return false rather
              than raising an error.</entry>
            </row>

            <row>
              <entry><xref linkend="is_double" /></entry>

              <entry>Check if the argument is a double value. If the argument
              is a simple variable reference and the referenced variable does
              not exist, the function will return false rather than raising an
              error.</entry>
            </row>

            <row>
              <entry><xref linkend="is_list" /></entry>

              <entry>Check if the argument is a list. If the argument is a
              simple variable reference and the referenced variable does not
              exist, the function will return false rather than raising an
              error.</entry>
            </row>

            <row>
              <entry><xref linkend="is_long" /></entry>

              <entry>Check if the argument is a long value. If the argument is
              a simple variable reference and the referenced variable does not
              exist, the function will return false rather than raising an
              error.</entry>
            </row>

            <row>
              <entry><xref linkend="is_nlist" /></entry>

              <entry>Check if the argument is an dict. If the argument is a
              simple variable reference and the referenced variable does not
              exist, the function will return false rather than raising an
              error.</entry>
            </row>

            <row>
              <entry><xref linkend="is_null" /></entry>

              <entry>Check if the argument is a <literal>null</literal>. If
              the argument is a simple variable reference and the referenced
              variable does not exist, the function will return false rather
              than raising an error.</entry>
            </row>

            <row>
              <entry><xref linkend="is_number" /></entry>

              <entry>Check if the argument is either a long or double value.
              If the argument is a simple variable reference and the
              referenced variable does not exist, the function will return
              false rather than raising an error.</entry>
            </row>

            <row>
              <entry><xref linkend="is_property" /></entry>

              <entry>Check if the argument is a property (long, double, or
              string). If the argument is a simple variable reference and the
              referenced variable does not exist, the function will return
              false rather than raising an error.</entry>
            </row>

            <row>
              <entry><xref linkend="is_resource" /></entry>

              <entry>Check if the argument is a list or dict. If the argument
              is a simple variable reference and the referenced variable does
              not exist, the function will return false rather than raising an
              error.</entry>
            </row>

            <row>
              <entry><xref linkend="is_string" /></entry>

              <entry>Check if the argument is a string value. If the argument
              is a simple variable reference and the referenced variable does
              not exist, the function will return false rather than raising an
              error.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Type Conversion Functions</title>

        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="1*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <tbody>
            <row>
              <entry><xref linkend="to_boolean" /></entry>

              <entry>Convert the argument to a boolean. Any number other than
              0 and 0.0 is <literal>true</literal>. The empty string and the
              string 'false' (ignoring case) return <literal>false</literal>.
              Any other string will return <literal>true</literal>. If the
              argument is a resource, an error will occur.</entry>
            </row>

            <row>
              <entry><xref linkend="to_double" /></entry>

              <entry>Convert the argument to a double value. Strings will be
              parsed to create a double value; any literal form of a double is
              valid. Boolean values will convert to <literal>0.0</literal> and
              <literal>1.0</literal> for <literal>false</literal> and
              <literal>true</literal>, respectively. Long values are converted
              to the corresponding double value. Double values are
              unchanged.</entry>
            </row>

            <row>
              <entry><xref linkend="to_long" /></entry>

              <entry>Convert the argument to a long value. Strings will be
              parsed to create a long value; any literal form of a long is
              valid (e.g. hex or octal literals). Boolean values will convert
              to <literal>0</literal> and <literal>1</literal> for
              <literal>false</literal> and <literal>true</literal>,
              respectively. Double values are rounded to the nearest long
              value. Long values are unchanged. An optional second argument
              can be provided that defines the radix to use.</entry>
            </row>

            <row>
              <entry><xref linkend="to_string" /></entry>

              <entry>Convert the argument to a string. The function will
              return a string representation for any argument, including list
              and dict.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Miscellaneous Functions</title>

        <tgroup cols="2">
          <colspec align="left" colnum="1" colwidth="1*" />

          <colspec align="left" colnum="2" colwidth="4*" />

          <tbody>
            <row>
              <entry><xref linkend="clone" /></entry>

              <entry>Create a deep copy of the given value.</entry>
            </row>

            <row>
              <entry><xref linkend="delete" /></entry>

              <entry>Delete a local variable or child of a local
              variable.</entry>
            </row>

            <row>
              <entry><xref linkend="exists" /></entry>

              <entry>Return true if the given argument exists. The argument
              can either be a variable reference, path, or template
              name.</entry>
            </row>

            <row>
              <entry><xref linkend="path_exists" /></entry>

              <entry>Return true if the given path exists. The argument must
              be an absolute or external path.</entry>
            </row>

            <row>
              <entry><xref linkend="if_exists" /></entry>

              <entry>For a given template name, return the template name if it
              exists or undef if it does not. This can be used with the
              include statement for a conditional include.</entry>
            </row>

            <row>
              <entry><xref linkend="return" /></entry>

              <entry>Interrupt the normal flow of processing and return the
              given value as the result of the current frame (either a
              function call or the main DML block).</entry>
            </row>

            <row>
              <entry><xref linkend="value" /></entry>

              <entry>Retrieve the value associated with the given path. The
              path may either be an absolute or external path.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>User-Defined Functions</title>

      <para>The pan language permits user-defined functions. These functions
      are essentially a DML block bound to an identifier. Only one DML block
      may be assigned to a given identifier. Attempts to redefine an existing
      function will cause the execution to be aborted. The syntax for defining
      a function is:</para>

      <programlisting>function <replaceable>identifier</replaceable> = DML;</programlisting>

      <para>where <replaceable>identifier</replaceable> is a valid pan
      identifier and DML is the block to bind to it.</para>

      <para>When the function is called, the DML will have the variables
      <varname>ARGC</varname> and <varname>ARGV</varname> defined. The
      variable <varname>ARGC</varname> contains the number of arguments passed
      to the function; <varname>ARGV</varname> is a list containing the values
      of the arguments.</para>

      <para>Note that <varname>ARGV</varname> is a standard pan list.
      Consequently, passing null values (intended to delete elements) to
      functions can have non-obvious effects. For example, the call:</para>

      <programlisting>f(null);</programlisting>

      <para>will result is an empty <varname>ARGV</varname> list because the
      null value deletes the nonexistent element
      <varname>ARGV[0]</varname>.</para>

      <para>The pan language does <emphasis>not</emphasis> check the number or
      types of arguments automatically. The DML block that defines the
      function must make all of these checks explicitly and use the
      <function>error</function> function to emit an informative message in
      case of an error.</para>

      <para>Recursive calls to a function are permitted. However, the call
      depth is limited (by an option when the compiler is invoked) to avoid
      infinite recursion. Typically, the maximum is a small number like 10.
      Recursion is expensive within the pan language and should be avoided if
      possible.</para>

      <para>The following example defines a function that checks if the number
      of arguments is even and are all numbers:</para>

      <programlisting>function paired_numbers = {

  if (ARGC%2 != 0) {
    error('number of arguments must be even'); 
  };

  foreach (k, v, ARGV) {
    if (! is_number(v)) {
      error('non-numeric argument found');
    };
  };

  'ok';

};</programlisting>
    </section>
  </chapter>

  <chapter>
    <title>Validation</title>

    <para>The greatest strength of the pan language is the ability to do
    detailed validation of configuration parameters, of correlated parameters
    within a machine profile, and of correlated parameters
    <emphasis>between</emphasis> machine profiles. Although the validation can
    make it difficult to get a particular machine profile to compile, the time
    spent getting a valid machine configuration before deployment more than
    makes up for the time wasted debugging a bad configuration that has been
    deployed.</para>

    <section>
      <title>Forcing Validation</title>

      <para>Simple validation through the validation of primitive properties
      and simple resources has already been covered when discussing the pan
      type definition features. This chapter deals with more complicated
      scenarios.</para>

      <para>The following statement will bind an existing type definition
      (either a built-in definition or a user-defined one) to a path in a
      machine configuration:</para>

      <programlisting>bind <replaceable>path</replaceable> = <replaceable>type-spec</replaceable>;</programlisting>

      <para>where <replaceable>path</replaceable> is a valid path name and
      <replaceable>type-spec</replaceable> is either a type specification or
      name of an existing type.</para>

      <para>Full type specifications are of the form:</para>

      <para><programlisting><replaceable>identifier</replaceable> = <replaceable>constant</replaceable> <literal>with</literal> <replaceable>validation-dml</replaceable></programlisting></para>

      <para>where <replaceable>constant</replaceable> is a DML block that
      evaluates to a compile-time constant (the default value), and the
      <replaceable>validation-dml</replaceable> is a DML block that will be
      run to validate paths associated with this type. Both the default value
      and validation block are optional. The
      <replaceable>identifier</replaceable> can be any legal name with an
      optional array specifier and/or range afterwards. For example, an array
      of 5 elements is written int[5] or a string of length 5 to 10 characters
      string(5..10).</para>
    </section>

    <section>
      <title>Implicit Typing</title>

      <para>If you worked through the previous chapters, you will have
      discovered that although you have an intuitive idea of what type a
      particular path should contain (e.g.
      <literal>/hardware/cpu/number</literal> should be positive long), the
      pan compiler does not. The compiler will infer an element's data type
      from the first value assigned to it. From then on it will enforce that
      type, raising an error if, for instance, a double is replaced by a
      string. If necessary, the implicit type can be removed from an element
      by assigning it to <literal>undef</literal> before changing the
      value.</para>
    </section>

    <section>
      <title>Binding Primitive Types to Paths</title>

      <para>Downstream machine configuration tools will likely expect
      parameters to have certain types, producing errors or erroneous
      configurations if the correct type is not used. One of the strengths of
      the pan language is to specify explicit constraints on the element to
      detect problems before configurations are deployed to machines.</para>

      <para>At the most basic level, a system administrator can tell the pan
      compiler that a particular element must be a particular type. This is
      done with the <literal>bind</literal> statement. To tell the compiler
      that the path <literal>/hardware/cpu/number</literal> must be a long
      value, add the following statement to the
      <literal>nfsserver.example.org</literal> example.</para>

      <programlisting>bind '/hardware/cpu/number' = long;</programlisting>

      <para>This statement can appear anywhere in the file; all of the
      specified constraints will be verified <emphasis>after</emphasis> the
      complete configuration is built. Setting this path to a value that is
      not a long or not setting the value at all will cause the compilation to
      fail.</para>

      <para>The above constraint only does part of the work though; the value
      could still be set to zero or a negative value without having the
      compiler complain. Pan also allows a range to be specified for primitive
      values. Changing the statement to the following:</para>

      <programlisting>bind '/hardware/cpu/number' = long(1..);</programlisting>

      <para>will require that the value be a positive long value. A valid
      range can have the minimum value, maximum value, or both specified. A
      range is always <emphasis>inclusive</emphasis> of the endpoint values.
      The endpoint values must be long literal values. A range specified as a
      single value indicates an exact match (e.g. <literal>3</literal> is
      short-hand for <literal>3..3</literal>). A range can be applied to a
      <type>long</type>, <type>double</type>, or <type>string</type> type
      definition. For strings, the range is applied to the length of the
      string.</para>
    </section>

    <section>
      <title>User-Defined Types</title>

      <para>Users can create new types built up from the primitive types and
      with optional validation functions. The general format for creating a
      new type is:</para>

      <programlisting>type <replaceable>identifier</replaceable> = <replaceable>type-spec</replaceable>;</programlisting>

      <para>where the general form for a type specification
      <replaceable>type-spec</replaceable> is given above.</para>

      <para>Probably the easiest way to understand the type definitions is by
      example. The following are "alias" types that associate a new name with
      an existing type, plus some restrictions.</para>

      <programlisting>type ulong1 = long with SELF &gt;= 0;
type ulong2 = long(0..);
type port = long(0..65535);
type short_string = string(..255);
type small_even = long(-16..16) with SELF % 2 == 0;</programlisting>

      <para>Similarly one can create link types for elements in the machine
      configuration:</para>

      <programlisting>type mylink = long(0..)* with match(SELF, 'r$');</programlisting>

      <para>Values associated to this type must be a string ending with 'r';
      the value must be a valid path that references an unsigned long
      value.</para>

      <para>Slightly more complex is to create uniform collections:</para>

      <programlisting>type long_list = long[10];
type matrix = long[3][4];
type double_dict = double{};
type small_even_dict = small_even{};</programlisting>

      <para>Here all of the elements of the collection have the same type. The
      last example shows that previously-defined, user types can be used as
      easily as the built-in primitive types.</para>

      <para>A record is an dict that explicitly names and types its children.
      A record is by far, the most frequently encountered type definition. For
      example, the type definition:</para>

      <programlisting>type cpu = {
  'vendor' : string
  'model' : string
  'speed' : double
  'fpu' ? boolean
};</programlisting>

      <para>defines an dict with four children named 'vendor', 'model', etc.
      The first three fields use a colon (":") in the definition and are
      consequently required fields; the last uses a question mark ("?") and is
      optional. As defined, no other children may appear in dicts of this
      type. However, one can make the record extensible with:</para>

      <programlisting>type cpu = extensible {
  'vendor' : string
  'model' : string
  'speed' : double
  'fpu' ? boolean
};</programlisting>

      <para>This will check the types of 'vendor', 'model', etc., but will
      also allow children of the dict with different unlisted names to appear.
      This provides some limited subclassing support. Each of the types for
      the children can be a full type specification and may contain default
      values and/or validation blocks. One can also attach default values or
      validation blocks to the record as a whole.</para>
    </section>

    <section>
      <title>Default Values</title>

      <para>Looking again at the <filename>nfsserver.example.org</filename>
      configuration, there are a couple of places where we could hope to use
      default values. The <literal>pxeboot</literal> and
      <literal>boot</literal> flags in the <type>nic</type> and
      <type>disk</type> type definitions could use default values. In both
      cases, at most one value will be set to <literal>true</literal>; all
      other values will be set to <literal>false</literal>. Another place one
      might want to use default values is in the <type>cpu</type> type;
      perhaps we would like to have <literal>number</literal> and
      <literal>cores</literal> both default to 1 if not specified.</para>

      <para>Pan allows type definitions to contain default values. For
      example, to change the three type definitions mentioned above:</para>

      <programlisting>type cpu = {
  'model' : string
  'speed' : double(0..)
  'arch' : string
  'cores' : long(1..) = 1
  'number' : long(1..) = 1
};

type nic = {
  'mac' : string
  'pxeboot' : boolean = false
};

type disk = {
  'label' ? string
  'capacity' : long(1..)
  'boot' : boolean = false
};</programlisting>

      <para>With these definitions, the lines which set the
      <literal>pxeboot</literal> and <literal>boot</literal> flags to false
      can be removed from the configuration and the compiler will still
      produce the same result. The default value will only be used if the
      corresponding element does not exist or has the <literal>undef</literal>
      value <emphasis>after all</emphasis> of the statements for an object
      have been executed. Consequently, a value that has been explicitly
      defined will always be used in preference to the default. Although one
      can set a default value for an optional field in a record, it will have
      an effect <emphasis>only</emphasis> if the value was explicitly set to
      <literal>undef</literal>.</para>

      <para>The default values must be a compile time constants.</para>
    </section>

    <section>
      <title>Advanced Parameter Validation</title>

      <para>Often there are cases where the legal values of a parameter cannot
      be expressed as a simple range. The pan language allows you to attach
      arbitrary validation code to a type definition. The code is attached to
      the type definition using the <literal>with</literal> keyword. Consider
      the following examples:</para>

      <programlisting>type even_positive_long = long(1..) with (SELF % 2 == 0);

type machine_state_enum = string 
    with match(SELF, 'open|closed|drain');

type ip = string with is_ipv4(SELF);</programlisting>

      <para>The validation code must return the boolean value
      <literal>true</literal>, if the associated value is correct. Returning
      any other value or raising an error with the <function>error</function>
      function will cause the build of the machine configuration to
      abort.</para>

      <para>Simple constraints are often written directly with the type
      statement; more complicated validation usually calls a separate
      function. The third line in the example above calls the function
      <function>is_ipv4</function>, which was defined in the next
      section.</para>
    </section>

    <section>
      <title>Validation Functions</title>

      <para>To simplify type definitions, validation functions are often
      defined. These are user-defined functions defined using the standard
      <command>function</command> statement. They can be referenced within a
      type definition just as they would be in any DML block. However,
      validation functions <emphasis>must</emphasis> return a boolean value or
      raise an error with the <function>error</function> function. A
      validation function that returns a non-boolean value will abort the
      compilation. Similarly, a validation function that returns
      <literal>false</literal> will raise an error indicating that the value
      for the tested element is invalid.</para>

      <para>A validation function that checks that a value is a valid IPv4
      address could look like:</para>

      <programlisting>function is_ipv4 = {
  terms = split('\.', ARGV[0]);
  foreach (index; term; terms) {
    i = to_long(term);
    if (i &lt; 0 || i &gt; 255) {
      return(false);
    };
  };
  true;
};</programlisting>

      <para>A real version of this function would probably do a great deal
      more checking of the value and probably raise errors with more intuitive
      error messages.</para>
    </section>

    <section>
      <title>Validation of Correlated Configuration Parameters</title>

      <para>Often the correct configuration of a machine requires that
      configuration parameters in different parts of the configuration are
      correlated. One example is the validation of the pre- and
      post-dependencies of the component configuration. It makes no sense for
      one component to depend on another one that is not defined in the
      configuration or is not active.</para>

      <para>The following validation function accomplishes such a check,
      assuming that the components are bound to
      <literal>/software/components</literal>:</para>

      <programlisting>function valid_component_list = {

  # ARGV[0] should be the list to check.

  # Check that each referenced component exists.
  foreach (k; v; ARGV[0]) {

    # Path to the root of the named component.
    path = '/software/components/' + v;

    if (!exists(path)) {
      error(path + ' does not exist');
    } else {

      # Path to the active flag for the named component.
      active_path = path + '/active';

      if (!(is_defined(active_path) &amp;&amp; value(active_path))) {
        error('component ' + v + ' isn't active');
      };

    };

  };

};

type component_list = string[] with valid_component_list(SELF);

type component = extensible {
  active : boolean = true
  pre ? component_list
  post ? component_list
};</programlisting>

      <para>It also defines a <type>component_list</type> type and uses this
      for a better definition of a the <type>component</type> type. This will
      get run on anything that is bound to the component type, directly or
      indirectly. Note how the function looks at other values in the
      configuration by creating the path and looking up the values with the
      <function>value</function> function.</para>

      <para>The above function works but has one disadvantage: it will only
      work for components defined below
      <literal>/software/components</literal>. If the list of components is
      defined elsewhere, then this schema definition will have to be modified.
      One can usually avoid this by applying the validation to a common
      parent. In this case, we can add the validation to the parent.</para>

      <programlisting>function valid_component_dict = {

  # Loop over each component.
  foreach (name; component; SELF) {

    if (exists(component['pre'])) {
      foreach (index; dependency; component['pre']) {
        if (!exists(SELF['dependency']['active'] ||
             SELF['dependency']['active'])) {
          error('non-existant or inactive dependency: ' 
                  + dependency);
        };
      };
    };

    # ... same for post ...

  };

};


type component = extensible {
  active : boolean = true;
  pre ? string[]
  post ? string[]
};

type component_dict = component{} with valid_component_dict(SELF);</programlisting>

      <para>This will accomplish the same validation, but will be independent
      of the location in the tree. It is, however, significantly more
      complicated to write and to understand the validation function. In the
      real world, the added complexity must be weighed against the likelihood
      that the type will be re-located within the configuration tree.</para>

      <para>The situation often arises that you want to validate a parameter
      against other siblings in the machine configuration tree. In this case,
      we wanted to ensure that other components were properly configured; to
      know that we needed to search "up and over" in the machine
      configuration. The pan language does not allow use of relative paths for
      the <function>value</function> function, so the two options are those
      presented here. Use an absolute path and reconstruct the paths or put
      the validation on a common parent.</para>
    </section>

    <section>
      <title>Cross-Machine Validation</title>

      <para>Another common situation is the need to validate machine
      configurations against each other. This often arises in client/server
      situations. For NFS, for instance, one would probably like to verify
      that a network share mounted on a client is actually exported by the
      server. The following example will do this:</para>

      <programlisting># Determine that a given mounted network share is actually
# exported by the server.
function valid_export = {

  info = ARGV[0];
  myhost = info['host'];
  mypath = info['path'];

  exports_path = host + ':/software/components/nfs/exports';
  
  found = false;
  if (path_exists(exports_path)) {

    exports = value(exports_path);

    foreach (index; einfo; exports) {
      if (einfo['authorized_host'] == myhost &amp;&amp;
          einfo['path'] == mypath) {
        found = true;
      };
    };

  };
  found;
};

# Defines path and authorized host for NFS server export.
type nfs_exports = {
  'path' : string
  'authorized_host' : string
};

# Type containing parameters to mount remote NFS volume.                        
type nfs_mounts = {
  'host' : string
  'path' : string           
  'mountpoint' : string
} with valid_export(SELF);

# Allows lists of NFS exports and NFS mounts (both optional).
type config_nfs = {
  include component
  'exports' ? nfs_exports[]
  'mounts'  ? nfs_mounts[]   
};</programlisting>

      <para>To do this type of validation, the full external path must be
      constructed for the <function>value</function> function. This has the
      same disadvantage as above in that if the schema is changed the function
      definition needs to be altered accordingly. The above code also assumes
      that the machine profile names are equivalent to the hostname. If
      another convention is being used, then the hostname will have to be
      converted to the corresponding machine name.</para>

      <para>It is worth noting that all of the validation is done
      <emphasis>after</emphasis> the machine configuration trees are built.
      This allows circular validation dependencies to be supported. That is,
      clients can check that they are properly included in the server
      configuration and the server can check that its clients are configured.
      A batch system is a typical example where this circular cross-validation
      is useful.</para>
    </section>

    <section>
      <title>Schemas</title>

      <para>The pan language allows complete configuration schema to be
      defined. Actually, you are capable of doing this already as defining a
      schema is nothing more than defining a type and binding that type to the
      root element. An example of this is:</para>

      <programlisting>object template schema_example;

include { 'type_definitions' };

type schema = {
  'software' : software_type
  'hardware' : hardware_type
  'packages' : packages_type
};

bind '/' = schema;

# Actual definitions of parameters.
# ...</programlisting>

      <para>In this fictitious example, the concrete types would be defined in
      the included file and the template would actually define the
      configuration parameters.</para>
    </section>
  </chapter>

  <chapter>
    <title>Modular Configurations</title>

    <para>Defining the configuration for a machine with many services, let
    alone a full site, quickly involves a large number of parameters. Often
    subsets of the configuration can be shared between services or machines.
    To minimize duplication and encourage sharing of configurations, the pan
    language has features to allow modularization of the configuration.</para>

    <section>
      <title>Include Statement</title>

      <para>So far only the hardware configuration and schema for one machine
      has been defined with the <literal>nfsserver.example.org</literal>
      configuration. One could imagine just doing a cut and paste to create
      the other three machines in our scenario. While this will work, the
      global site configuration will quickly become unwieldy and error-prone.
      In particular the schema is something that should be shared between all
      or many machines on a site. Multiple copies means multiple copies to
      keep up-to-date and multiple chances to introduce errors.</para>

      <para>To encourage reuse of the configuration and to reduce maintenance
      effort, pan allows one template to include another (with some
      limitations). For example, the above schema can be pulled into another
      template (named <filename>common/schema.tpl</filename>) and included in
      the main object template.</para>

      <programlisting>declaration template common/schema;

type location = extensible {
  'rack' : string
  'slot' : long(0..50)
};

type cpu = {
  'model' : string
  'speed' : double(0..)
  'arch' : string
  'cores' : long(1..)
  'number' : long(1..)
};

type disk = {
  'label' ? string
  'capacity' : long(1..)
  'boot' : boolean
};

type disks = {
  'ide' ? disk[]
  'scsi' ? disk{}
};

type nic = {
  'mac' : string
  'pxeboot' : boolean
};

type hardware = {
  'location' : location
  'ram' : long(0..)
  'cpu' : cpu
  'disks' : disks
  'nic' : nic[]
};

type root = {
  'hardware' : hardware
};</programlisting>

      <para>The main object template then becomes:</para>

      <programlisting>object template nfsserver.example.org;

include 'common/schema';

bind '/' = root;

'/hardware/location/rack' = 'IBM04';
'/hardware/location/slot' = 25;

'/hardware/ram' = 2048;

'/hardware/cpu/model' = 'Intel Xeon';
'/hardware/cpu/speed' = 2.5;
'/hardware/cpu/arch' = 'x86_64';
'/hardware/cpu/cores' = 4;
'/hardware/cpu/number' = 2;

'/hardware/disk/ide/0/capacity' = 64;
'/hardware/disk/ide/0/boot' = true;
'/hardware/disk/ide/0/label' = 'system';
'/hardware/disk/ide/1/capacity' = 1024;
'/hardware/disk/ide/1/boot' = false;

'/hardware/nic/0/mac' = '01:23:45:ab:cd:99';
'/hardware/nic/0/pxeboot' = false;
'/hardware/nic/1/mac' = '01:23:45:ab:cd:00';
'/hardware/nic/1/pxeboot' = true;</programlisting>

      <para>There are three important changes to point out.</para>

      <para>First, there is a new pan statement in the
      <literal>nfsserver.example.org</literal> template to include the schema.
      The <command>include</command> statement takes the name of the template
      to include as a string; the braces are mandatory. If the template is not
      included directly on the command line, then the compiler will search the
      <emphasis>loadpath</emphasis> for the template. If the loadpath is not
      specified, then it defaults to the current working directory.</para>

      <para>Second, the schema has been pulled out into a separate file. The
      first line of that schema template is now marked as a
      <literal>declaration</literal> template. Such a template can only
      include type, variable, and function declarations. Such a template will
      be included at most once when building an object; all inclusions after
      the first will be ignored. This allows many different template to
      reference type (and function) declarations that they use without having
      to worry about accidentally redefining them.</para>

      <para>Third, the schema template name is
      <literal>common/schema</literal> and must be located in a file called
      <filename>common/schema.pan</filename>; that is, it must be in a
      subdirectory of the current directory called
      <filename>common</filename>. This is called
      <emphasis>namespacing</emphasis> and allows the templates that make up a
      configuration to be organized into subdirectories. For the few templates
      that are used here, namespacing is not critical. It is, however,
      critical for real sites that are likely to have hundreds or thousands of
      templates. Note that the hierarchy for namespaces is completely
      independent of the hierarchy used in the configuration schema.</para>

      <para>Pulling out common declarations and help maintain coherence
      between different managed machines and reduce the overall size of the
      configuration. There are however, more mechanisms to reduce
      duplication.</para>
    </section>

    <section>
      <title>Structure Templates</title>

      <para>Sites usually buy many identical machines in a single purchase, so
      much of the hardware configuration for those machines is the same.
      Another mechanism that can be exploited to reuse configuration
      parameters is a <literal>structure</literal> template. Such a template
      defines an dict that is initially independent of the configuration tree
      itself. For our scenario, let us assume that the four machines have
      identical RAM, CPU, and disk configurations; the NIC and location
      information is different for each machine. The following template pulls
      out the common information into a <literal>structure</literal>
      template:</para>

      <programlisting>structure template common/machine/ibm-server-model-123;

'ram' = 2048;

'cpu/model' = 'Intel Xeon';
'cpu/speed' = 2.5;
'cpu/arch' = 'x86_64';
'cpu/cores' = 4;
'cpu/number' = 2;

'disk/ide/0/capacity' = 64;
'disk/ide/0/boot' = true;
'disk/ide/0/label' = 'system';
'disk/ide/1/capacity' = 1024;
'disk/ide/1/boot' = false;

'location' = undef;
'nic' = undef;</programlisting>

      <para>The structure template is not rooted into the configuration (yet)
      and hence all of the paths in the assignment statements must be
      <emphasis>relative</emphasis>; that is, they do not begin with a slash.
      Also, the <literal>location</literal> and <literal>nic</literal>
      children were set to <literal>undef</literal>. These are the values that
      will vary from machine to machine, but we want to ensure that anyone
      using this template sets those values. If someone uses this template,
      but forgets to set those values, the compiler will abort the compilation
      with an error. The <literal>undef</literal> value may not appear in a
      final configuration.</para>

      <para>How is this used in the machine configuration? The
      <command>include</command> statement will not work because we must
      indicate where the configuration should be rooted. The answer is to use
      an assignment statement along with the <function>create</function>
      function.</para>

      <programlisting>object template nfsserver.example.org;

include 'common/schema';

bind '/' = root;

'/hardware' = create('common/machine/ibm-server-model-123');

'/hardware/location/rack' = 'IBM04';
'/hardware/location/slot' = 25;

'/hardware/nic/0/mac' = '01:23:45:ab:cd:99';
'/hardware/nic/0/pxeboot' = false;
'/hardware/nic/1/mac' = '01:23:45:ab:cd:00';
'/hardware/nic/1/pxeboot' = true;</programlisting>

      <para>Finally, the machine configuration contains only values that
      depend on the machine itself with common values pulled in from shared
      templates.</para>

      <para>Although the example here uses the hardware configuration, in
      reality it can be used for any subtree that is invariant or
      nearly-invariant. One can even reuse the same structure template many
      times in the same object just be creating a new instance and assigning
      it to a particular part of the tree.</para>
    </section>
  </chapter>

  <chapter>
    <title>Advanced Features</title>

    <para>This chapter discusses annotations and logging, two advanced topics
    that can be used to facilitate the management of sites and better
    understand a site's configuration.</para>

    <section>
      <title>Annotations</title>

      <para>The compiler supports pan language annotations and provides a
      mechanism for recovering those annotations in a separate XML file. While
      the compiler permits annotations to occur in nearly any location in a
      source file, only annotations attached to certain syntactic elements can
      be recovered. Currently these are those before the template declaration,
      variable declarations, function declarations, type declarations, and
      field specifications. Examples of all are in the example file.</para>

      <programlisting>@maintainer{
  name = Jane Manager
  email = jane.manager@example.org
}
@{
  Example template that shows off the 
  annotation features of the compiler.
}
object template annotations;

@use{
  type = long
  default = 1
  note = negative values raise an exception
}
variable VALUE ?= 1;

@documentation{
  desc = simple addition of two numbers
  arg = first number to add
  arg = second number to add
}
function ADD = {
 ARGV[0] + ARGV[1];
};

type EXTERN = {
  'info' ? string
};

@documentation{
  Simple definition of a key value pair.
}
type KV_PAIR = extensible {

  @{additional information fields}
  include EXTERN

  @{key for pair as string} 
  'key' : string

  @{value for pair as string}
  'value' : string = to_string(2 + 3)
};

bind '/pair' = KV_PAIR;

'/add' = ADD(1, 2);

'/pair/key' = 'KEY';
'/pair/value' = 'VALUE';</programlisting>

      <para>The command will produce one output file for each source file,
      using the directory hierarchy of the source files, <emphasis>not the
      namespace hierarchy</emphasis>. When processing the files, you must
      provide both the desired output directory (which must exist) using the
      <option>--output-dir</option> option, as well as the root file system
      directory for all of the processed files with the
      <option>--base-dir</option> option. Using the following command to
      process the file:</para>

      <programlisting>$ panc-annotations \
  --output-dir=annotations \
  --base-dir=. \
  annotations.pan</programlisting>

      <para>will produce the following output in the file
      <filename>annotations.pan.annotation.xml</filename> (with whitespace and
      indentation added for clarity).</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;template xmlns="http://quattor.org/pan/annotations" 
          name="annotations" 
          type="OBJECT"&gt;
    &lt;desc&gt;
  Example template that shows off the 
  annotation features of the compiler.
&lt;/desc&gt;

    &lt;maintainer&gt;
        &lt;name&gt;Jane Manager&lt;/name&gt;
        &lt;email&gt;jane.manager@example.org&lt;/email&gt;
    &lt;/maintainer&gt;

    &lt;variable name="VALUE"&gt;
        &lt;use&gt;
            &lt;type&gt;long&lt;/type&gt;
            &lt;default&gt;1&lt;/default&gt;
            &lt;note&gt;negative values raise an exception&lt;/note&gt;
        &lt;/use&gt;
    &lt;/variable&gt;

    &lt;function name="ADD"&gt;
        &lt;documentation&gt;
            &lt;desc&gt;simple addition of two numbers&lt;/desc&gt;
            &lt;arg&gt;first number to add&lt;/arg&gt;
            &lt;arg&gt;second number to add&lt;/arg&gt;
        &lt;/documentation&gt;
    &lt;/function&gt;

    &lt;type name="EXTERN"&gt;
        &lt;basetype extensible="no"&gt;
            &lt;field name="info" required="no"&gt;
                &lt;basetype name="string" extensible="no"/&gt;
            &lt;/field&gt;
        &lt;/basetype&gt;
    &lt;/type&gt;

    &lt;type name="KV_PAIR"&gt;
        &lt;documentation&gt;
            &lt;desc&gt;
  Simple definition of a key value pair.
&lt;/desc&gt;
        &lt;/documentation&gt;

        &lt;basetype extensible="yes"&gt;
            &lt;include name="EXTERN"/&gt;
            &lt;field name="key" required="yes"&gt;
                &lt;desc&gt;key for pair as string&lt;/desc&gt;
                &lt;basetype name="string" extensible="no"/&gt;
            &lt;/field&gt;
            &lt;field name="value" required="yes"&gt;
                &lt;desc&gt;value for pair as string&lt;/desc&gt;
                &lt;basetype name="string" extensible="no"/&gt;
            &lt;/field&gt;
        &lt;/basetype&gt;

    &lt;/type&gt;
    &lt;basetype name="KV_PAIR" extensible="no"/&gt;
&lt;/template&gt;</programlisting>

      <para>The output filename includes the full input filename because
      variants with different suffixes may be present.</para>
    </section>

    <section>
      <title>Logging</title>

      <para>It is possible to log various activities of the pan compiler. The
      types of logging that can be specified are:</para>

      <variablelist>
        <varlistentry>
          <term>task</term>

          <listitem>
            <para>Task logging can be used to extract information about how
            long the various processing phases last for a particular object
            template. The build phases one will see in the log file are:
            execute, defaults, valid1, valid2, xml, and dep. There is also a
            build stage that combines the execute and defaults stages.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>call</term>

          <listitem>
            <para>Call logging allows the full inclusion graph to be
            reconstructed, including function calls. Each include is logged
            even if the include would not actually include a file because the
            included file is a declaration or unique template that has already
            been included.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>include</term>

          <listitem>
            <para>Include logging only logs the inclusion of templates and
            does not log function calls.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>memory</term>

          <listitem>
            <para>Memory logging show the memory usage during template
            processing. This can be used to see the progression of memory
            utilization and can be correlated with other activities if other
            types of logging are enabled.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>all</term>

          <listitem>
            <para>Turns all types of logging on.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>none</term>

          <listitem>
            <para>Turns all types of logging off.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Note that a log file name must also be specified, otherwise the
      logging information will not be saved.</para>

      <para>The logging information can be used to understand the performance
      of the compiler and find bottlenecks in the configuration. It can also
      be used to extract information about the relationships between
      templates, which are then commonly passed to visualization tasks to
      allow a better understanding of the configuration. Many examples are
      included in the distribution as analysis scripts. See the command
      reference appendix for details.</para>
    </section>

    <section>
      <title>Build Metadata</title>

      <para>It is sometimes useful to be able to inject values into the
      compiled profiles without having to explicitly include a template into
      each object template. This is particularly appropriate for metadata like
      build numbers, build times, build machines, etc. This can be achieved by
      setting the root element that is used to start the build of all
      profiles. Use the <option>rootElement</option> attribute for ant and the
      <option>--root-element</option> option for the command line. The value
      must be a DML expression that evaluates to an dict. For example, this
      expression</para>

      <programlisting>dict('build-metadata', dict('number', 1, 'date', '2012-01-01'))</programlisting>

      <para>would result in having the paths
      <filename>/build-metadata/number</filename>,
      <filename>/build-metadata/date</filename> being set to
      <literal>1</literal> and <literal>2012-01-01</literal>, respectively, in
      all object templates.</para>

      <caution>
        <para>Values inserted into the profiles in this way are still subject
        to the usual validation. When inserting values, they must obey the
        schema you have defined for the profile.</para>
      </caution>
    </section>
  </chapter>

  <chapter>
    <title>Performance Considerations</title>

    <para>As configurations become larger, the speed at which the full
    configuration can be compiled becomes important. The logging features
    presented in the previous chapter can help identify slow parts of the
    compilation for you particular configuration. This chapter contains
    general advice on making the compilation as quick as possible.</para>

    <section>
      <title>Use Specific Paths</title>

      <para>Whenever possible, use the most specific path and assign a
      property to that path. The code:</para>

      <programlisting>'/path' = dict('a', 1, 'b', 2);</programlisting>

      <para>and the block:</para>

      <programlisting>'/path/a' = 1;
'/path/b' = 2;</programlisting>

      <para>provide identical results, although the second example is easier
      to read and will be better optimized by the compiler.</para>
    </section>

    <section>
      <title>Use Escaped Literal Path Syntax</title>

      <para>In previous versions of the compiler, it was necessary to use a
      DML block when part of a path needed to be escaped:</para>

      <programlisting>'/path' = dict(escape('a/b'), 1);</programlisting>

      <para>Newer versions of the compiler provide a literal path syntax in
      which escaped portions can be written explicitly:</para>

      <programlisting>'/path/{a/b}' = 1;</programlisting>

      <para>This is both more legible and faster.</para>
    </section>

    <section>
      <title>Use Built-In Functions</title>

      <para>Built-in functions are significantly faster than equivalents
      defined with the pan language. In particular, the functions
      <function>append</function> and <function>prepend</function> should be
      used for incrementally building up lists (in preference to
      <function>push</function> equivalents). There are also functions like
      <function>to_uppercase</function> and <function>to_lowercase</function>
      that avoid character by character manipulation of strings.</para>

      <para>The list of available built-in functions continues to expand.
      Check the list of functions with each new release of the
      compiler.</para>
    </section>

    <section>
      <title>Invoking the Compiler</title>

      <para>There are several ways to invoke the compiler, either from the
      command line, from ant, or from maven. For single, infrequent
      invocations of the compiler they are roughly equivalent in startup time.
      However, if the compiler will be invoked frequently it is better to
      avoid using the command line panc script. The reason for this is that
      the panc script starts a new JVM each time it is invoked, while the ant
      and maven invocations can reuse their own JVM. This means that for the
      panc script, you will pay the startup costs each time it is invoked
      while for ant or maven you pay it them only once. The startup costs are
      particularly expensive if you request a large amount of memory and do
      hundreds of compilations at a time.</para>
    </section>

    <section>
      <title>Avoid Copying SELF</title>

      <para>Assignments of <varname>SELF</varname> to a local variable inside
      of a code block will cause a deep copy of <varname>SELF</varname>. In
      the following code, the local variable <varname>copy</varname> will
      contain a complete replica of <varname>SELF</varname>.</para>

      <programlisting>'/path' = {
 copy = SELF;
 copy;
};</programlisting>

      <para>These copies can be time-consuming when <varname>SELF</varname> is
      a large resource or when the code is executed frequently. If you
      manipulate <varname>SELF</varname> within a code block,
      <emphasis>always</emphasis> reference <varname>SELF</varname>
      directly.</para>

      <para>Also be aware that <varname>copy</varname> and
      <varname>SELF</varname> will contain independent copies so that changes
      to <varname>copy</varname> to not affect <varname>SELF</varname> and
      vice versa. This can lead to bugs that are difficult to find.</para>
    </section>
  </chapter>

  <chapter>
    <title>Common Idioms</title>

    <para>As you use the pan configuration, you will discover certain idioms
    which appear. This chapter describes some of the common idioms so that you
    can take advantage of them from the start and not need to rediscover them
    yourself.</para>

    <section>
      <title>Configuration File Templates</title>

      <para>Although it is much better to create an abstracted schema for
      service configuration, practically it is often useful to directly embed
      a configuration file directly in the service configuration. In previous
      versions of the compiler, the configuration file was often created
      incrementally in a global variable and then assigned to a path.
      Something like the following was common:</para>

      <programlisting>variable USER = 'smith';
variable QUOTA = 10;

variable CONTENTS = &lt;&lt;EOF;
alpha = 1
beta = 2
EOF

variable CONTENTS = CONTENTS + 
    'user = ' + USER + "\n";

variable CONTENTS = CONTENTS + 
    'quota = ' + to_string(QUOTA) + "\n";


'/cfgfile' = CONTENTS;</programlisting>

      <para>This can be improved somewhat by using the
      <function>format</function> function:</para>

      <programlisting>variable USER = 'smith';
variable QUOTA = 10;


variable CFG_TEMPLATE = &lt;&lt;EOF;
alpha = 1
beta = 2
user = %s
quota = %d
EOF

'/cfgfile' = format(CFG_TEMPLATE, USER, QUOTA);</programlisting>

      <para>This can be further improved by moving the configuration template
      completely out of the pan language file. For instance, create the file
      <filename>cfg-template.txt</filename>:</para>

      <programlisting>alpha = 1
beta = 2
user = %s
quota = %d</programlisting>

      <para>which can then be used like this:</para>

      <programlisting>variable USER = 'smith';
variable QUOTA = 10;

'/cfgfile' = format(file_contents('cfg-template.txt'), 
                    USER, QUOTA);</programlisting>

      <para>This is much easier to read and to maintain. It is especially
      helpful when the included configuration file has a syntax for which an
      external editor can provide additional help with validation.</para>
    </section>

    <section>
      <title>Extension Templates</title>

      <para>Often sets of templates that are intended for reuse will allow the
      configuration to be extended or modified at particular points by
      including named templates. For example, the following provides
      pre-configuration and post-configuration service hooks:</para>

      <programlisting>template my_service/config;

include if_exists('my_service/prehook');

# bulk of real service configuration

include if_exists('my_service/posthook');</programlisting>

      <para>In both of these cases, the named templates will be included if
      they can be found on the loadpath. If they are not found, the includes
      do nothing.</para>
    </section>

    <section>
      <title>Global Variables as Switches</title>

      <para>Configuration intended for reuse also tends to expose switches for
      common configuration options. The idiom looks like the following:</para>

      <programlisting>template my_service/config;

variable MY_OPTION ?= false;

'/my_service/config/my_option' = 
  if (MY_OPTION) {
    'some value';
  } else {
    'some other value';
  };
};</programlisting>

      <para>In cases where the path simply should not exist if the option is
      not set, then using a default value of null can be the best
      option:</para>

      <programlisting>template my_service/config;

variable MY_OPTION ?= null;

'/my_service/config/my_option' = MY_OPTION;</programlisting>

      <para>In this case, if the variable MY_OPTION is not set to a value
      before executing this template, the null value will be used and the
      given path will simply be deleted.</para>
    </section>

    <section>
      <title>Tri-state Variables</title>

      <para>Occasionally is is useful to have tri-state variables. The most
      convenient values to use in this case are <literal>true</literal>,
      <literal>false</literal>, and <literal>null</literal>. With these values
      as the three states, you can use <function>is_null</function> to test
      explicitly for the third state. Using <literal>undef</literal> for the
      third value can cause problems because variables are automatically set
      to <literal>undef</literal> before executing a variable assignment
      statement.</para>
    </section>
  </chapter>

  <chapter>
    <title>Troubleshooting</title>

    <para></para>

    <section>
      <title>Compilation Problems</title>

      <para>In a production environment, the number of templates and their
      complexity will be must greater. Often something goes wrong with the
      compilation or build resulting in one or more errors appearing on the
      console (standard error stream). There are four categories of
      errors:</para>

      <variablelist>
        <varlistentry>
          <term>Syntax Error</term>

          <listitem>
            <para>These include any errors that can be caught during the
            compilation of a single template. These include lexing, parsing,
            and syntax errors, but also semantic errors like absolute
            assignment statements appearing in a structure template that can
            be caught at compilation time.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Evaluation Error</term>

          <listitem>
            <para>These are the most common; these include any error that
            happens during the "execution" phase of processing like
            mathematical errors, primitive type conflicts, and the like.
            Usually the name of the template and the location where the error
            occurred will be included in the error message.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Validation Error</term>

          <listitem>
            <para>Validation errors occur during the "validation" phase and
            indicate that the generated machine profile violates the defined
            schema. Information about what type specification was violated and
            the offending path will be included in the error message.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>System Error</term>

          <listitem>
            <para>These include low-level problems like problems reading from
            or writing to the file system.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>In general, the errors try to indicate as precisely as possible
      the problem. Usually the name of the source file as well as the location
      inside the file (line and column numbers) are indicated. For most
      evaluation exceptions, a traceback is also provided. Validation errors
      are the most terse, giving only the element causing the problem and the
      location of the type definition that has been violated.</para>

      <para>There is one further class of errors called "compiler errors".
      These indicate an error in the logic of the compiler itself and should
      be accompanied by a detailed error message and a Java traceback. All
      compiler errors should be reported as a bug. The bug report should
      include the template that caused the problem along with the full Java
      traceback. Hopefully, you will not encounter these errors.</para>
    </section>

    <section>
      <title>Common Problems</title>

      <qandaset>
        <qandadiv>
          <qandaentry>
            <question>
              <para>"Java Heap Space" warnings appear on console.</para>

              <para>If you see messages that refer to "Java Heap Space" while
              running the compiler, then the java virtual machine does not
              have enough memory to compile the given templates. You must
              increase the amount of memory allocated to the java virtual
              machine when you start the compiler. See the section Running the
              Compiler for how to specify the VM memory.</para>
            </question>
          </qandaentry>

          <qandaentry>
            <question>
              <para>The compilation is extremely slow.</para>

              <para>If the compilation appears to be slow, check that the
              compiler is not thrashing because of a limited amount of memory.
              With the verbose option set, successful compilations will
              produce a summary like:</para>

              <screen>2 templates
2/2 compiled, 2/2 xml, 0/0 dep
0 errors, 166 ms, 0 MB/63 MB heap, 12 MB/116 MB nonheap</screen>

              <para>The last line with gives the maximum amount of heap memory
              used and the maximum available (the value marked "heap"). If the
              maximum used is more than about 80% of the maximum available,
              then you should consider increasing the memory allocated to the
              java virtual machine. See the section Running the Compiler for
              how to specify the VM memory.</para>
            </question>
          </qandaentry>

          <qandaentry>
            <question>
              <para>"missing modifyThread Permission" warnings appear on
              console.</para>

              <para>The java-implementation of the pan language compiler is
              completely multi-threaded. Internally, it controls several
              thread pools to handle compilation, execution, and serialization
              in parallel. At the end of a compilation, the compiler will
              normally destroy the thread pools that were created. The java
              security model requires that a program have the "modifyThread"
              permission to destroy threads. In some environments (notably
              Eclipse), this permission may not be given to the compiler. If
              this is the case, then the message "WARNING: missing
              modifyThread permission" is printed on the standard error.
              Lacking this permission causes a "thread leak", but the effects
              are minor unless an extremely large number of templates are
              being compiled. If this is the case, then you should either
              change the configuration to grant this permission to the
              compiler, or work in an environment that grants it by default
              (e.g. using ant from the command line).</para>

              <para>This problem is fixed if using Java6. If you have several
              JREs installed, be sure to configure Eclipse to use Java 6. Go
              to Window → Preferences → Java → Installed JREs. If you don't
              see the JRE you want (and you have it installed), use the
              "Search" button to have eclipse configure the new JRE for you.
              Make sure you select it after it is found.</para>
            </question>
          </qandaentry>

          <qandaentry>
            <question>
              <para>Unnecessary rebuild of clusters</para>

              <para>It can happen that a cluster is always rebuilt when you
              run ant, even if there was no change in the dependencies. In
              this case, you may suspect a Java issue with optimizations
              enabled by default (JIT). The only workaround is to disable
              these optimizations by adding the option -Xint to Java VM when
              running ant. It is achieved differently depending how you
              started ant:</para>

              <itemizedlist>
                <listitem>
                  <para>From command line: define environment variable
                  ANT_OPTS.</para>
                </listitem>

                <listitem>
                  <para>From Eclipse: right click on build.xml in ant pane,
                  choose Run As... → External Tools... and then click on JRE
                  tab. Be sure to use a separate JRE (if possible Java 6 or
                  later) and add option in the options area.</para>
                </listitem>
              </itemizedlist>

              <para>This problem has been seen on Windows only, with Java 5
              and Java 6.</para>
            </question>
          </qandaentry>
        </qandadiv>
      </qandaset>
    </section>

    <section>
      <title>Bug Reporting</title>

      <para>The pan compiler, like all software, contains bugs. If the problem
      your experiencing looks to be misbehavior by the compiler, please report
      the problem. Bug reports can be filed in the in the issues area of
      GitHub.</para>

      <screen>https://github.com/quattor/pan/issues</screen>
    </section>
  </chapter>

  <xi:include href="appendix/appendix-obtain-panc.xml" xpointer="element(/1)" />

  <xi:include href="appendix/appendix-run-panc.xml" xpointer="element(/1)" />

  <xi:include href="appendix/appendix-commands.xml" xpointer="element(/1)" />

  <xi:include href="appendix/appendix-built-in-functions.xml"
              xpointer="element(/1)" />
</book>
